<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Find nearby stores from the holistic wellness hit list">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stores Nearby</title>

    <!-- Open Graph tags for WhatsApp and social media previews -->
    <meta property="og:title" content="Stores Nearby">
    <meta property="og:description" content="Find nearby stores from the holistic wellness hit list">
    <meta property="og:image" content="https://github.com/TrueSightDAO/.github/blob/main/assets/20240612_truesight_dao_logo_square.png?raw=true">
    <meta property="og:url" content="https://truesightdao.github.io/dapp/">
    <meta property="og:type" content="website">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://github.com/TrueSightDAO/.github/blob/main/assets/20240612_truesight_dao_logo_square.png?raw=true">          
    <script>
        window.__tsdGoogleMaps = window.__tsdGoogleMaps || {
            ready: false,
            callbacks: [],
            placesLib: null,
            error: null
        };
        window.onGoogleMapsReady = async function () {
            try {
                window.__tsdGoogleMaps.placesLib = await google.maps.importLibrary("places");
                window.__tsdGoogleMaps.ready = true;
            } catch (err) {
                window.__tsdGoogleMaps.error = err;
                console.error('Google Maps initialization failed:', err);
            } finally {
                const queued = window.__tsdGoogleMaps.callbacks.splice(0);
                queued.forEach(callback => {
                    try {
                        if (typeof callback === 'function') {
                            callback();
                        }
                    } catch (callbackError) {
                        console.error('Google Maps ready callback error:', callbackError);
                    }
                });
            }
        };
    </script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBWmnvjWeYIEju0JLbfN-Z09k1HEsXzWe4&callback=onGoogleMapsReady&v=weekly&loading=async&libraries=places"></script>
    <script src="./menu.js"></script>
    
    <!-- Leaflet.js for maps (no API key required) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 1rem;
            padding: 1rem;
            min-height: 100vh;
            box-sizing: border-box;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            width: 100%;
            background-color: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            font-size: 1.8rem;
            color: #333;
            margin: 0.5rem 0 1rem;
            text-align: center;
        }
        #description {
            font-style: italic;
            color: #555;
            line-height: 1.5;
            margin: 0.8rem 0;
            font-size: 1rem;
            text-align: center;
        }
        .form-group {
            margin: 1rem 0;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #333;
        }
        input[type="number"], select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        input[type="text"],
        input[type="tel"],
        input[type="url"],
        input[type="email"],
        textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        textarea {
            min-height: 90px;
            resize: vertical;
        }
        .location-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        .location-two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        .btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            width: 100%;
            margin: 0.5rem 0;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background-color: #0056b3;
        }
        .btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: #6c757d;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        #status {
            margin: 1rem 0;
            font-weight: bold;
            min-height: 24px;
            font-size: 1rem;
            text-align: center;
        }
        .status {
            color: #28a745;
        }
        .error {
            color: #dc3545;
        }
        .loading {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
        }
        .loading .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .stores-list {
            margin: 1rem 0;
        }
        .store-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .store-card:hover {
            border-color: #007bff;
            box-shadow: 0 2px 4px rgba(0,123,255,0.1);
        }
        .store-card.expanded {
            border-color: #007bff;
            box-shadow: 0 4px 8px rgba(0,123,255,0.15);
        }
        .store-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            margin-top: 1rem;
            padding-top: 0;
            border-top: none;
        }
        .store-card.expanded .store-details {
            max-height: 2000px;
            padding-top: 1rem;
            border-top: 2px solid #dee2e6;
            margin-top: 1rem;
        }
        .store-details-section {
            margin: 1rem 0;
        }
        .store-details-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }
        .store-details-content {
            color: #555;
            line-height: 1.6;
            font-size: 0.9rem;
        }
        .store-details-link {
            color: #007bff;
            text-decoration: none;
            word-break: break-all;
        }
        .store-details-link:hover {
            text-decoration: underline;
        }
        .status-update-select {
            cursor: pointer;
        }
        .status-update-select:disabled {
            background-color: #f5f5f5;
            cursor: not-allowed;
        }
        .expand-indicator {
            text-align: center;
            color: #6c757d;
            font-size: 0.85rem;
            margin-top: 0.5rem;
            font-style: italic;
        }
        .store-card.expanded .expand-indicator {
            display: none;
        }
        .duplicate-notice {
            background-color: #fff8e1;
            border-left: 3px solid #ffb300;
            padding: 0.75rem;
            border-radius: 4px;
            color: #7a5300;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        .duplicate-notice strong {
            font-weight: 600;
        }
        .duplicate-notice button {
            background: none;
            border: none;
            color: #007bff;
            padding: 0;
            cursor: pointer;
            text-decoration: underline;
            font-size: 0.9rem;
            margin-top: 0.35rem;
        }
        .duplicate-highlight {
            animation: duplicatePulse 1.2s ease-in-out 2;
            box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.35);
        }
        @keyframes duplicatePulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.6); }
            100% { box-shadow: 0 0 0 8px rgba(255, 193, 7, 0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #welcome {
            text-align: center;
            font-size: 1.1rem;
            color: #28a745;
            margin: 1rem 0;
            font-weight: 600;
        }
        .store-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .store-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            flex: 1;
        }
        .store-distance {
            background: #007bff;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .store-info {
            color: #555;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        .store-meta {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
            font-size: 0.9rem;
            color: #6c757d;
        }
        .store-coordinates {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 0.85rem;
            background: #e8f4ff;
            color: #0d6efd;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            border: 1px solid rgba(13, 110, 253, 0.25);
        }
        .store-followup {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #495057;
            line-height: 1.4;
        }
        .store-followup strong {
            font-weight: 600;
        }
        .store-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }
        .badge-high {
            background: #dc3545;
            color: white;
        }
        .badge-medium {
            background: #ffc107;
            color: #333;
        }
        .badge-low {
            background: #6c757d;
            color: white;
        }
        .badge-contacted {
            background: #28a745;
            color: white;
        }
        .badge-research {
            background: #17a2b8;
            color: white;
        }
        .badge-followup {
            background: #ffc107;
            color: #333;
            font-weight: 600;
        }
        .badge-followedup {
            background: #6f42c1;
            color: white;
            font-weight: 500;
        }
        .badge-instagram-followed {
            background: #e1306c;
            color: white;
        }
        .badge-meeting-scheduled {
            background: #007bff;
            color: white;
            font-weight: 500;
        }
        .badge-partnered {
            background: #28a745;
            color: white;
            font-weight: 600;
        }
        .badge-on-hold {
            background: #ffc107;
            color: #333;
        }
        .badge-rejected {
            background: #dc3545;
            color: white;
        }
        .store-details-link {
            color: #007bff;
            text-decoration: none;
        }
        .store-details-link:hover {
            text-decoration: underline;
        }
        .store-card.highlight {
            animation: highlightFade 2.5s ease-out;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.35);
        }
        @keyframes highlightFade {
            0% { box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.75); }
            100% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0); }
        }
        .share-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .share-message {
            font-size: 0.85rem;
            color: #007bff;
            margin-top: 0.25rem;
        }
        .share-message.error {
            color: #dc3545;
        }
        .share-message.success {
            color: #28a745;
        }
        .signature-banner {
            display: none;
            background: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.95rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        .signature-banner a {
            color: #0c5460;
            font-weight: 600;
            text-decoration: none;
        }
        .signature-banner a:hover {
            text-decoration: underline;
        }
        .signature-locked-hint {
            display: none;
            font-size: 0.9rem;
            color: #6c757d;
            margin-top: 0.5rem;
            text-align: center;
        }
        .requires-signature-soft-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        @media (max-width: 600px) {
            .location-inputs {
                grid-template-columns: 1fr;
            }
            .location-two-column {
                grid-template-columns: 1fr;
            }
            /* Optimize filter dropdowns for mobile */
            .filter-dropdowns-container {
                display: flex !important;
                flex-direction: column !important;
                gap: 1rem !important;
            }
            .form-group select {
                font-size: 1rem !important;
                padding: 0.875rem !important;
                min-height: 44px !important; /* iOS recommended tap target size */
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
                background-repeat: no-repeat;
                background-position: right 0.75rem center;
                background-size: 1.2em;
                padding-right: 2.5rem !important;
                border: 1px solid #ddd !important;
                border-radius: 4px !important;
            }
            .form-group label {
                font-size: 0.95rem !important;
                margin-bottom: 0.5rem !important;
            }
            .store-card {
                padding: 0.8rem;
            }
            .store-details-content {
                font-size: 0.85rem;
            }
        }
        #logo {
            height: 200px;
            display: block;
            margin: 0 auto 1.5rem;
            max-width: 100%;
        }
        #map {
            height: 400px;
            width: 100%;
            border-radius: 8px;
            border: 1px solid #ddd;
            margin: 1rem 0;
            position: relative;
            transition: height 0.3s ease, width 0.3s ease;
        }
        /* Leaflet attribution styling */
        .leaflet-control-attribution {
            font-size: 0.75rem !important;
            padding: 2px 5px !important;
            line-height: 1.3 !important;
        }
        #map.expanded {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            border-radius: 0;
            margin: 0;
            border: none;
        }
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 0.5rem;
            flex-direction: column;
        }
        .map-control-btn {
            background: white;
            border: 2px solid #007bff;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 1.2rem;
            transition: all 0.2s ease;
            z-index: 1001;
        }
        .map-control-btn:hover {
            background: #007bff;
            color: white;
            transform: scale(1.1);
        }
        .map-control-btn:active {
            transform: scale(0.95);
        }
        .map-loading-indicator {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            display: none;
            align-items: center;
            gap: 0.5rem;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 0.9rem;
            font-weight: 600;
            color: #007bff;
        }
        .map-loading-indicator.show {
            display: flex;
        }
        .map-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e0e0e0;
            border-top-color: #007bff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .expanded-map-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            display: none;
        }
        .expanded-map-overlay.show {
            display: block;
        }
        .expanded-map-header {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 1rem 1.5rem;
            z-index: 10000;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
            display: none;
            align-items: center;
            gap: 1rem;
            min-height: 50px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .expanded-map-header.show {
            display: flex;
        }
        .expanded-map-header h3 {
            margin: 0;
            flex: 1;
            font-size: 1.1rem;
            line-height: 1.4;
            font-weight: 600;
        }
        .expanded-map-header select {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .expanded-map-header .close-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .expanded-map-header .close-btn:hover {
            background: #c82333;
        }
        .expanded-map-header .toggle-panel-btn {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            margin-right: 0.5rem;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        .expanded-map-header .toggle-panel-btn:hover {
            background: #5a6268;
        }
        .expanded-map-header.collapsed {
            max-height: 50px;
            padding: 0;
            overflow: hidden;
        }
        .expanded-map-header.collapsed .toggle-panel-btn {
            margin: 0;
            border-radius: 0;
            width: 100%;
            height: 50px;
            border-radius: 4px 4px 0 0;
        }
        .expanded-map-header.collapsed > *:not(.toggle-panel-btn) {
            opacity: 0;
            pointer-events: none;
            max-height: 0;
            overflow: hidden;
        }
        .expanded-map-header {
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        .expanded-map-header > *:not(.toggle-panel-btn) {
            transition: opacity 0.2s ease, max-height 0.3s ease;
        }
        #map.expanded {
            bottom: 0;
            padding-bottom: 80px; /* Space for bottom header */
            transition: padding-bottom 0.3s ease;
        }
        #map.expanded.panel-hidden {
            padding-bottom: 50px; /* Space for collapsed toggle button only */
        }
        #map.expanded .map-controls {
            top: 10px;
            z-index: 10001;
        }
        #map.expanded .map-loading-indicator {
            top: 60px;
            z-index: 10001;
        }
        .numbered-marker {
            background: transparent !important;
            border: none !important;
        }
        @media (max-width: 600px) {
            #map {
                height: 300px;
            }
            .map-control-btn {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }
            .expanded-map-header {
                flex-direction: column;
                align-items: stretch;
                padding: 0.75rem 1rem;
            }
            .expanded-map-header h3 {
                font-size: 1rem;
                line-height: 1.4;
                margin-bottom: 0.5rem;
            }
            #map.expanded {
                bottom: 0;
                padding-bottom: 180px; /* More space for mobile header with two filters */
            }
            #map.expanded.panel-hidden {
                padding-bottom: 50px; /* Space for collapsed toggle button only on mobile */
            }
            .expanded-map-header.collapsed {
                max-height: 50px;
                padding: 0;
            }
            .expanded-map-header.collapsed .toggle-panel-btn {
                width: 100%;
                height: 50px;
            }
            .expanded-map-header .expanded-multi-select-container {
                max-height: 120px !important;
                font-size: 0.8rem !important;
            }
            .expanded-map-header label {
                padding: 0.375rem !important;
                font-size: 0.8rem !important;
            }
            .expanded-map-header .close-btn {
                width: 100%;
            }
            #map.expanded .map-controls {
                top: 10px;
            }
            #map.expanded .map-loading-indicator {
                top: 60px;
            }
        }
    </style>
</head>
<body>
    <div id="navDropdown" style="margin:1rem 0; text-align:center;"></div>
    <div class="container">
        <div style="text-align: center;">
            <img id="logo" height="200px" src="https://github.com/TrueSightDAO/.github/blob/main/assets/20240612_truesight_dao_logo_square.png?raw=true" alt="TrueSight DAO Logo"/>
        </div>
        
        <h1>Stores Nearby</h1>
        <p id="description">
            Find the top 10 stores nearest to your location. Filter by status to see stores that match your criteria.
        </p>

        <div id="welcome" style="display: none; margin: 1rem 0;"></div>
        <p id="status" class="fade-in" style="margin: 1rem 0; font-weight: bold; min-height: 24px; font-size: 1rem; text-align: center;">Verifying your digital signature...</p>
        <div id="signaturePromptBanner" class="signature-banner">
            You are currently viewing stores in read-only mode. <a href="./create_signature.html">Generate your digital signature</a> to add or update store information.
        </div>
        
        <div id="storesContent" style="display: none;">
            <!-- Store Suggestion Quick Capture -->
            <div class="store-card" id="newStoreCard">
                <div class="store-header">
                    <div class="store-name">ðŸ’¡ Suggest a Store</div>
                    <button type="button"
                            class="btn btn-secondary"
                            id="newStoreToggleBtn"
                            data-requires-signature="true"
                            style="width: auto; padding: 0.4rem 1rem;">
                        Share Details
                    </button>
                </div>
                <div class="store-details" id="newStoreDetails">
                    <div class="store-details-content">
                        <p style="font-size: 0.9rem; color: #6c757d; margin-bottom: 1rem;">
                            Spotlight a hidden gem in your neighborhood. We'll pre-fill what we can from your location so you can stay present in the moment.
                        </p>
                        <form id="newStoreForm" data-requires-signature="true">
                            <div class="form-group">
                                <label for="newStoreName">Shop Name *</label>
                                <input type="text" id="newStoreName" required placeholder="e.g. Mystic Flora Apothecary">
                                <div id="newStoreAutocompleteHost" style="display: none;"></div>
                            </div>

                            <div class="form-group">
                                <label for="newStoreAddress">Street Address</label>
                                <input type="text" id="newStoreAddress" placeholder="Street address">
                                <div id="newStoreAddressAutocompleteHost" style="display: none;"></div>
                                <small style="color: var(--muted); font-size: 0.875rem; margin-top: 0.25rem; display: block;">Start typing an address to auto-populate fields</small>
                            </div>

                            <div class="form-group location-two-column">
                                <div>
                                    <label for="newStoreCity">City</label>
                                    <input type="text" id="newStoreCity" placeholder="City">
                                </div>
                                <div>
                                    <label for="newStoreState">State</label>
                                    <select id="newStoreState">
                                        <option value="">Select</option>
                                        <option value="AL">Alabama</option>
                                        <option value="AK">Alaska</option>
                                        <option value="AZ">Arizona</option>
                                        <option value="AR">Arkansas</option>
                                        <option value="CA">California</option>
                                        <option value="CO">Colorado</option>
                                        <option value="CT">Connecticut</option>
                                        <option value="DE">Delaware</option>
                                        <option value="DC">District of Columbia</option>
                                        <option value="FL">Florida</option>
                                        <option value="GA">Georgia</option>
                                        <option value="HI">Hawaii</option>
                                        <option value="ID">Idaho</option>
                                        <option value="IL">Illinois</option>
                                        <option value="IN">Indiana</option>
                                        <option value="IA">Iowa</option>
                                        <option value="KS">Kansas</option>
                                        <option value="KY">Kentucky</option>
                                        <option value="LA">Louisiana</option>
                                        <option value="ME">Maine</option>
                                        <option value="MD">Maryland</option>
                                        <option value="MA">Massachusetts</option>
                                        <option value="MI">Michigan</option>
                                        <option value="MN">Minnesota</option>
                                        <option value="MS">Mississippi</option>
                                        <option value="MO">Missouri</option>
                                        <option value="MT">Montana</option>
                                        <option value="NE">Nebraska</option>
                                        <option value="NV">Nevada</option>
                                        <option value="NH">New Hampshire</option>
                                        <option value="NJ">New Jersey</option>
                                        <option value="NM">New Mexico</option>
                                        <option value="NY">New York</option>
                                        <option value="NC">North Carolina</option>
                                        <option value="ND">North Dakota</option>
                                        <option value="OH">Ohio</option>
                                        <option value="OK">Oklahoma</option>
                                        <option value="OR">Oregon</option>
                                        <option value="PA">Pennsylvania</option>
                                        <option value="RI">Rhode Island</option>
                                        <option value="SC">South Carolina</option>
                                        <option value="SD">South Dakota</option>
                                        <option value="TN">Tennessee</option>
                                        <option value="TX">Texas</option>
                                        <option value="UT">Utah</option>
                                        <option value="VT">Vermont</option>
                                        <option value="VA">Virginia</option>
                                        <option value="WA">Washington</option>
                                        <option value="WV">West Virginia</option>
                                        <option value="WI">Wisconsin</option>
                                        <option value="WY">Wyoming</option>
                                    </select>
                                </div>
                            </div>

                            <div class="form-group">
                                <input type="hidden" id="newStoreLat">
                                <input type="hidden" id="newStoreLng">
                                <button type="button"
                                        id="newStoreUseLocation"
                                        style="background: none; border: none; padding: 0; color: #007bff; font-size: 0.85rem; cursor: pointer; text-decoration: underline; margin-bottom: 0.25rem;">
                                    Use current location instead
                                </button>
                                <div id="newStoreCoordinatesDisplay" style="font-size: 0.85rem; color: #343a40; margin-bottom: 0.35rem; display: none;">
                                    <strong>Coordinates:</strong> <span id="newStoreCoordinatesText"></span>
                                </div>
                                <div id="newStoreLocationStatus" style="font-size: 0.85rem; color: #6c757d;"></div>
                            </div>

                            <div class="form-group">
                                <label for="newStorePhone">Phone</label>
                                <input type="tel" id="newStorePhone" placeholder="(xxx) xxx-xxxx">
                            </div>

                            <div class="form-group">
                                <label for="newStoreEmail">Email</label>
                                <input type="email" id="newStoreEmail" placeholder="email@example.com">
                            </div>

                            <div class="form-group">
                                <label for="newStoreWebsite">Website</label>
                                <input type="url" id="newStoreWebsite" placeholder="https://example.com">
                            </div>

                            <div class="form-group">
                                <label for="newStoreInstagram">Instagram</label>
                                <input type="url" id="newStoreInstagram" placeholder="https://instagram.com/handle">
                            </div>

                            <div class="form-group">
                                <label for="newStoreShopType">Shop Type</label>
                                <select id="newStoreShopType">
                                    <option value="Metaphysical/Spiritual">Metaphysical / Spiritual</option>
                                    <option value="Wellness Center">Wellness Center</option>
                                    <option value="Health Food Store">Health Food Store</option>
                                    <option value="Natural Goods" selected>Natural Goods</option>
                                    <option value="Conscious Cafe">Conscious Cafe</option>
                                    <option value="Boutique Chocolate">Boutique Chocolate</option>
                                    <option value="Antique Store">Antique Store</option>
                                    <option value="Gift Shop">Gift Shop</option>
                                    <option value="Candy Store">Candy Store</option>
                                    <option value="Yoga Studio">Yoga Studio</option>
                                    <option value="Apothecary">Apothecary</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="newStoreStatus">Status</label>
                                <select id="newStoreStatus">
                                    <option value="Research">Research</option>
                                    <option value="Shortlisted">Shortlisted</option>
                                    <option value="Instagram Followed">Instagram Followed</option>
                                    <option value="Contacted">Contacted</option>
                                    <option value="Manager Follow-up">Manager Follow-up</option>
                                    <option value="Meeting Scheduled">Meeting Scheduled</option>
                                    <option value="Followed Up">Followed Up</option>
                                    <option value="Partnered">Partnered</option>
                                    <option value="On Hold">On Hold</option>
                                    <option value="Rejected">Rejected</option>
                                    <option value="Not Appropriate">Not Appropriate</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="newStoreRemarks">Remarks (optional)</label>
                                <textarea id="newStoreRemarks" placeholder="Notes, next steps, or context from the visit..."></textarea>
                            </div>

                            <div id="newStoreStatusMessage" style="margin: 0.75rem 0; font-size: 0.9rem;"></div>

                            <button type="submit"
                                    class="btn"
                                    id="newStoreSubmitBtn"
                                    style="width: 100%; padding: 0.7rem; font-size: 1rem;">
                                Save New Store
                            </button>
                        </form>
                        <div id="newStoreLockedMessage" class="signature-locked-hint">
                            Ready to recommend a store? <a href="./create_signature.html">Generate your digital signature</a> to unlock the form.
                        </div>
                    </div>
                </div>
            </div>
            <!-- Status Filter - Primary control, most important -->
            <div class="form-group" style="margin-bottom: 1.5rem;">
                <div class="filter-dropdowns-container" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <label style="font-weight: 600; margin: 0;">Filter by Status:</label>
                            <span id="statusFilterCount" style="font-size: 0.875rem; color: #007bff; font-weight: 600; background: #e7f3ff; padding: 0.25rem 0.5rem; border-radius: 12px; min-width: 2rem; text-align: center;">0 selected</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <button type="button" id="selectAllStatuses" style="flex: 1; padding: 0.5rem; font-size: 0.875rem; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; transition: background 0.2s;">Select All</button>
                            <button type="button" id="clearAllStatuses" style="flex: 1; padding: 0.5rem; font-size: 0.875rem; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; transition: background 0.2s;">Clear All</button>
                        </div>
                        <div class="multi-select-container" style="border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: white; max-height: 200px; overflow-y: auto; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);">
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Research" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Research</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Shortlisted" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Shortlisted</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Instagram Followed" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Instagram Followed</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Contacted" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Contacted</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Manager Follow-up" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Manager Follow-up</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Meeting Scheduled" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Meeting Scheduled</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Followed Up" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Followed Up</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Partnered" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Partnered</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="On Hold" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">On Hold</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Rejected" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Rejected</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="status-filter-checkbox" value="Not Appropriate" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #007bff;">
                                <span style="flex: 1;">Not Appropriate</span>
                            </label>
                        </div>
                        <div id="statusFilterSummary" style="margin-top: 0.5rem; font-size: 0.875rem; color: #6c757d; min-height: 1.25rem; font-style: italic;"></div>
                    </div>
                    <div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <label style="font-weight: 600; margin: 0;">Filter by Shop Type:</label>
                            <span id="shopTypeFilterCount" style="font-size: 0.875rem; color: #28a745; font-weight: 600; background: #d4edda; padding: 0.25rem 0.5rem; border-radius: 12px; min-width: 2rem; text-align: center;">0 selected</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <button type="button" id="selectAllShopTypes" style="flex: 1; padding: 0.5rem; font-size: 0.875rem; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; transition: background 0.2s;">Select All</button>
                            <button type="button" id="clearAllShopTypes" style="flex: 1; padding: 0.5rem; font-size: 0.875rem; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; transition: background 0.2s;">Clear All</button>
                        </div>
                        <div class="multi-select-container" style="border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: white; max-height: 200px; overflow-y: auto; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);">
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Metaphysical/Spiritual" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Metaphysical / Spiritual</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Wellness Center" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Wellness Center</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Health Food Store" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Health Food Store</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Natural Goods" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Natural Goods</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Conscious Cafe" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Conscious Cafe</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Boutique Chocolate" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Boutique Chocolate</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Antique Store" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Antique Store</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Gift Shop" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Gift Shop</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Candy Store" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Candy Store</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Yoga Studio" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Yoga Studio</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Apothecary" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Apothecary</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.5rem; cursor: pointer; user-select: none; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <input type="checkbox" class="shop-type-filter-checkbox" value="Other" style="margin-right: 0.75rem; cursor: pointer; width: 18px; height: 18px; accent-color: #28a745;">
                                <span style="flex: 1;">Other</span>
                            </label>
                        </div>
                        <div id="shopTypeFilterSummary" style="margin-top: 0.5rem; font-size: 0.875rem; color: #6c757d; min-height: 1.25rem; font-style: italic;"></div>
                    </div>
                </div>
                <div id="statusDescription" style="margin-top: 0.5rem; padding: 0.75rem; background-color: #f8f9fa; border-left: 3px solid #007bff; border-radius: 4px; font-size: 0.9rem; color: #495057; line-height: 1.5;">
                    <strong>ðŸ“‹ Status:</strong> <span id="statusDescriptionText">Select status(es) to see their meaning</span>
                </div>
            </div>

            <!-- Location Controls - Primary action -->
            <div style="margin-bottom: 1.5rem; text-align: center;">
                <button type="button" class="btn" id="useCurrentLocation" style="width: 100%; max-width: 400px; padding: 0.75rem 1.5rem; font-size: 1rem; margin-bottom: 1rem;">
                    ðŸ“ Use Current Location
                </button>
                <p id="locationStatus" style="font-size: 0.9rem; color: #6c757d; margin-top: 0.5rem; min-height: 1.5rem;">
                    Click to detect your current location
                </p>
            </div>

            <!-- Map View - Visual context -->
            <div class="form-group" style="margin-bottom: 1.5rem;">
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Map View:</label>
                <div id="map">
                    <div class="map-controls">
                        <button class="map-control-btn" id="expandMapBtn" title="Maximize map" style="display: none;">â›¶</button>
                        <button class="map-control-btn" id="collapseMapBtn" title="Minimize map" style="display: none;">â›¶</button>
                    </div>
                    <div class="map-loading-indicator" id="mapLoadingIndicator">
                        <div class="map-loading-spinner"></div>
                        <span>Loading stores...</span>
                    </div>
                </div>
                <p style="font-size: 0.9rem; color: #6c757d; margin-top: 0.75rem; margin-bottom: 0.5rem; text-align: center; line-height: 1.5;">
                    Your location and nearby stores are shown on the map
                </p>
            </div>
            
            <!-- Expanded Map Header -->
            <div class="expanded-map-header" id="expandedMapHeader">
                <button id="togglePanelBtn" class="toggle-panel-btn" title="Toggle panel visibility">
                    <span id="togglePanelIcon">â–¼</span>
                </button>
                <div style="flex: 1;">
                    <h3>Map View - Explore Stores</h3>
                    <div id="expandedMapLocationCount" style="font-size: 0.875rem; color: #6c757d; margin-top: 0.25rem;">
                        <span id="expandedMapLocationCountText">0 locations loaded</span>
                    </div>
                </div>
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: flex-start;">
                    <div style="flex: 1; min-width: 200px;">
                        <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.9rem;">Status (multiple):</label>
                        <div class="expanded-multi-select-container" style="border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: white; max-height: 150px; overflow-y: auto; font-size: 0.875rem;">
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Research" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Research</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Shortlisted" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Shortlisted</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Instagram Followed" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Instagram Followed</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Contacted" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Contacted</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Manager Follow-up" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Manager Follow-up</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Meeting Scheduled" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Meeting Scheduled</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Followed Up" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Followed Up</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Partnered" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Partnered</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="On Hold" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>On Hold</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Rejected" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Rejected</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-status-filter-checkbox" value="Not Appropriate" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Not Appropriate</span>
                            </label>
                        </div>
                    </div>
                    <div style="flex: 1; min-width: 200px;">
                        <label style="display: block; margin-bottom: 0.25rem; font-weight: 600; font-size: 0.9rem;">Shop Type (multiple):</label>
                        <div class="expanded-multi-select-container" style="border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: white; max-height: 150px; overflow-y: auto; font-size: 0.875rem;">
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Metaphysical/Spiritual" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Metaphysical / Spiritual</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Wellness Center" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Wellness Center</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Health Food Store" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Health Food Store</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Natural Goods" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Natural Goods</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Conscious Cafe" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Conscious Cafe</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Boutique Chocolate" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Boutique Chocolate</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Antique Store" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Antique Store</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Gift Shop" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Gift Shop</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Candy Store" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Candy Store</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Yoga Studio" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Yoga Studio</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Apothecary" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Apothecary</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 0.25rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" class="expanded-shop-type-filter-checkbox" value="Other" style="margin-right: 0.5rem; cursor: pointer;">
                                <span>Other</span>
                            </label>
                        </div>
                    </div>
                </div>
                <button class="close-btn" id="closeExpandedMapBtn">Close Map</button>
            </div>
            
            <!-- Expanded Map Overlay -->
            <div class="expanded-map-overlay" id="expandedMapOverlay"></div>

            <!-- Search Button - Secondary action -->
            <form id="searchForm" style="margin-bottom: 1.5rem;">
                <button type="submit" class="btn" id="searchBtn" style="width: 100%; max-width: 400px; padding: 0.75rem 1.5rem; font-size: 1rem; display: block; margin: 0 auto;">
                    ðŸ” Find Nearby Stores
                </button>
            </form>

            <!-- Status Messages -->
            <div id="statusMessage" style="margin-bottom: 1rem;"></div>

            <!-- Results - Stores List -->
            <div id="storesContainer"></div>
        </div>
    </div>

    <script>
        // Google Apps Script deployment URLs
        const API_URL = 'https://script.google.com/macros/s/AKfycbwB2zqNV9nMCMWs2hSa8FecjA36Oh-mSVuz3pk8TpXrXcy9dvqOqgbWIirNka2LmacgPw/exec';                   
        const SIGNATURE_VERIFY_API = 'https://script.google.com/macros/s/AKfycbygmwRbyqse-dpCYMco0rb93NSgg-Jc1QIw7kUiBM7CZK6jnWnMB5DEjdoX_eCsvVs7/exec';        

        const stateNameLookup = {
            'alabama': 'AL', 'alaska': 'AK', 'arizona': 'AZ', 'arkansas': 'AR',
            'california': 'CA', 'colorado': 'CO', 'connecticut': 'CT', 'delaware': 'DE',
            'district of columbia': 'DC', 'florida': 'FL', 'georgia': 'GA', 'hawaii': 'HI',
            'idaho': 'ID', 'illinois': 'IL', 'indiana': 'IN', 'iowa': 'IA',
            'kansas': 'KS', 'kentucky': 'KY', 'louisiana': 'LA', 'maine': 'ME',
            'maryland': 'MD', 'massachusetts': 'MA', 'michigan': 'MI', 'minnesota': 'MN',
            'mississippi': 'MS', 'missouri': 'MO', 'montana': 'MT', 'nebraska': 'NE',
            'nevada': 'NV', 'new hampshire': 'NH', 'new jersey': 'NJ', 'new mexico': 'NM',
            'new york': 'NY', 'north carolina': 'NC', 'north dakota': 'ND', 'ohio': 'OH',
            'oklahoma': 'OK', 'oregon': 'OR', 'pennsylvania': 'PA', 'rhode island': 'RI',
            'south carolina': 'SC', 'south dakota': 'SD', 'tennessee': 'TN', 'texas': 'TX',
            'utah': 'UT', 'vermont': 'VT', 'virginia': 'VA', 'washington': 'WA',
            'west virginia': 'WV', 'wisconsin': 'WI', 'wyoming': 'WY'
        };

        const statusDescriptions = {
            'Research': 'Store is being researched. Gathering information about the store, their products, and potential fit.',
            'Shortlisted': 'Store looks promising and is queued for outreach or in-person visit. Prepare materials and plan next steps.',
            'Instagram Followed': 'Store has been followed on Instagram. Monitoring their social media presence and engagement.',
            'Contacted': 'Initial contact has been made with the store. This is the first step in the outreach process.',
            'Manager Follow-up': 'Store visit completed. Staff indicated to follow up with the manager using provided contact details. Action required.',
            'Meeting Scheduled': 'Meeting or call has been scheduled with the store owner/manager. Prepare for the conversation.',
            'Followed Up': 'Follow-up contact with the manager has been completed. Waiting for their response or next steps.',
            'Partnered': 'Store is an active partner. They carry our products and have an established business relationship.',
            'On Hold': 'Store partnership is temporarily on hold. Waiting for further developments or decisions.',
            'Rejected': 'Store declined partnership or is not interested in carrying our products.',
            'Not Appropriate': 'Store does not align with our values or target market. Not a good fit for partnership.',
            '': 'Showing all stores regardless of status. Use this to see the complete list.'
        };

        function updateStatusDescription(statusValue) {
            const descriptionEl = document.getElementById('statusDescriptionText');
            if (descriptionEl) {
                const description = statusDescriptions[statusValue] || 'No description available for this status.';
                descriptionEl.textContent = description;
            }
        }

        // Track if this is the first automatic load
        let isFirstLoad = true;
        let contributorName = '';
        let map = null;
        let userMarker = null;
        let storeMarkers = [];
        let currentLat = null;
        let currentLng = null;
        let newStoreFormInitialized = false;
        let deepLinkCoordinates = null;
        let deepLinkLocationApplied = false;
        let currentLocationLabel = 'Your Location (Start)';
        const googleMapsState = window.__tsdGoogleMaps || {
            ready: false,
            callbacks: [],
            placesLib: null,
            error: null
        };
        let placeAutocompleteElement = null;
        let addressAutocompleteElement = null;
        let interactionMode = 'view-only';
        let pendingStoreDeepLink = null;
        let lastSignatureNotice = 0;
        const knownStoresByKey = new Map();

        function updateNewStoreCoordinatesUI() {
            const latInput = document.getElementById('newStoreLat');
            const lngInput = document.getElementById('newStoreLng');
            const displayEl = document.getElementById('newStoreCoordinatesDisplay');
            const textEl = document.getElementById('newStoreCoordinatesText');
            const statusEl = document.getElementById('newStoreLocationStatus');

            if (!latInput || !lngInput || !displayEl || !textEl) {
                return;
            }

            const latValue = latInput.value.trim();
            const lngValue = lngInput.value.trim();
            const latNumber = parseFloat(latValue);
            const lngNumber = parseFloat(lngValue);

            if (latValue && lngValue && !Number.isNaN(latNumber) && !Number.isNaN(lngNumber)) {
                textEl.textContent = `${latNumber.toFixed(4)}, ${lngNumber.toFixed(4)}`;
                displayEl.style.display = 'block';
                if (statusEl && !statusEl.innerHTML) {
                    statusEl.innerHTML = `<span style="color: #28a745;">Coordinates ready for submission</span>`;
                }
            } else {
                textEl.textContent = '';
                displayEl.style.display = 'none';
                if (statusEl && statusEl.innerHTML === '<span style="color: #28a745;">Coordinates ready for submission</span>') {
                    statusEl.innerHTML = '';
                }
            }
        }

        function initializeDeepLinkFromQuery() {
            try {
                const params = new URLSearchParams(window.location.search);
                const storeKey = params.get('store');
                const statusParam = params.get('status');
                const latParam = params.get('lat');
                const lngParam = params.get('lng');
                if (statusParam) {
                    // Set checkbox for the status from URL parameter
                    const checkbox = document.querySelector(`.status-filter-checkbox[value="${statusParam}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                        checkbox.dispatchEvent(new Event('change'));
                    }
                        updateStatusDescription(statusParam);
                }
                if (latParam && lngParam) {
                    const parsedLat = parseFloat(latParam);
                    const parsedLng = parseFloat(lngParam);
                    if (!Number.isNaN(parsedLat) && !Number.isNaN(parsedLng)) {
                        deepLinkCoordinates = {
                            lat: parsedLat,
                            lng: parsedLng
                        };
                    }
                }
                if (storeKey) {
                    pendingStoreDeepLink = {
                        storeKey: storeKey.toLowerCase()
                    };
                }
            } catch (error) {
                console.warn('Deep link parse error:', error);
            }
        }

        function normalizeForKey(value) {
            return (value || '')
                .toString()
                .trim()
                .toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9\-]/g, '');
        }

        function createStoreKey(store) {
            const parts = [
                normalizeForKey(store.name),
                normalizeForKey(store.address),
                normalizeForKey(store.city),
                normalizeForKey(store.state)
            ].filter(Boolean);
            return parts.join('__') || normalizeForKey(store.name) || '';
        }

        function findStoreIndexByKey(targetKey) {
            if (!Array.isArray(window.storesData) || !targetKey) {
                return -1;
            }
            const normalizedTarget = targetKey.toLowerCase();
            let index = window.storesData.findIndex(store => {
                const key = (store.storeKey || createStoreKey(store) || '').toLowerCase();
                return key === normalizedTarget;
            });
            if (index !== -1) {
                return index;
            }
            const targetName = normalizedTarget.split('__')[0];
            if (!targetName) {
                return -1;
            }
            index = window.storesData.findIndex(store => normalizeForKey(store.name) === targetName);
            if (index !== -1) {
                return index;
            }
            return -1;
        }

        function buildStoreShareLink(store) {
            const baseUrl = `${window.location.origin}${window.location.pathname}`;
            const url = new URL(baseUrl);
            const storeKey = createStoreKey(store);
            if (storeKey) {
                url.searchParams.set('store', storeKey);
            }
            if (store.status) {
                url.searchParams.set('status', store.status);
            }
            return url.toString();
        }

        function buildStoreShareText(store, options = {}) {
            const includeLink = options.includeLink !== false;
            const lines = [];
            if (store.name) {
                lines.push(store.name);
            }
            const addressParts = [
                store.address || '',
                store.city || '',
                store.state || ''
            ].filter(Boolean);
            if (addressParts.length > 0) {
                lines.push(addressParts.join(', '));
            }
            const link = includeLink ? buildStoreShareLink(store) : null;
            if (includeLink && link) {
                lines.push('');
                lines.push('For more context:');
                lines.push(link);
            }
            return lines.join('\n');
        }

        function showShareMessage(elementId, type, message) {
            const el = typeof elementId === 'string' ? document.getElementById(elementId) : elementId;
            if (!el) return;
            el.textContent = message;
            el.classList.remove('error', 'success');
            if (type === 'error') {
                el.classList.add('error');
            } else if (type === 'success') {
                el.classList.add('success');
            }
            el.classList.add('share-message');
        }

        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera || '';
            const touchCapable = navigator.maxTouchPoints && navigator.maxTouchPoints > 1;
            return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase()) ||
                   (touchCapable && window.matchMedia && window.matchMedia('(pointer:coarse)').matches);
        }

        function handleStoreShare(event, index) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            if (!window.storesData || !window.storesData[index]) {
                return;
            }
            const store = window.storesData[index];
            const messageId = `shareMessage-${index}`;
            const shareTextFull = buildStoreShareText(store, { includeLink: true });
            const shareTextPreview = buildStoreShareText(store, { includeLink: false });
            const shareLink = buildStoreShareLink(store);

            async function shareNative() {
                try {
                    await navigator.share({
                        title: store.name || 'Store Highlight',
                        text: shareTextPreview,
                        url: shareLink
                    });
                    showShareMessage(messageId, 'success', 'Shared via system dialog.');
                } catch (error) {
                    if (error && error.name === 'AbortError') {
                        return;
                    }
                    throw error;
                }
            }

            function shareViaWhatsApp() {
                const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(shareTextFull)}`;
                window.open(whatsappUrl, '_blank');
                showShareMessage(messageId, 'success', 'Opening WhatsApp share...');
            }

            const onDesktopCopy = () => {
                copyStoreShare(event, index, 'Copied share text to clipboard. Paste into WhatsApp or your channel.');
            };

            if (isMobileDevice() && navigator.share) {
                shareNative().catch(() => {
                    shareViaWhatsApp();
                });
            } else {
                onDesktopCopy();
            }
        }

        async function copyStoreShare(event, index, successMessage) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            if (!window.storesData || !window.storesData[index]) {
                return;
            }
            const store = window.storesData[index];
            const messageId = `shareMessage-${index}`;
            const shareText = buildStoreShareText(store);

            if (navigator.clipboard && navigator.clipboard.writeText) {
                try {
                    await navigator.clipboard.writeText(shareText);
                    showShareMessage(messageId, 'success', successMessage || 'Copied summary to clipboard.');
                    return;
                } catch (error) {
                    console.warn('Clipboard write failed, falling back:', error);
                }
            }

            // Fallback: create temporary textarea
            const textarea = document.createElement('textarea');
            textarea.value = shareText;
            textarea.setAttribute('readonly', '');
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showShareMessage(messageId, 'success', successMessage || 'Copied summary to clipboard.');
            } catch (error) {
                console.error('Unable to copy share text:', error);
                showShareMessage(messageId, 'error', 'Unable to copy text. Please copy manually.');
            } finally {
                document.body.removeChild(textarea);
            }
        }

        function scrollStoreCardIntoView(index, options = {}) {
            const card = document.getElementById(`store-card-${index}`);
            if (card) {
                const viewportOffset = options.offset !== undefined ? options.offset : 120;
                const rect = card.getBoundingClientRect();
                const targetTop = window.pageYOffset + rect.top - viewportOffset;
                window.scrollTo({
                    top: targetTop < 0 ? 0 : targetTop,
                    behavior: 'smooth'
                });
            }
        }

        function highlightStoreCard(index) {
            const card = document.getElementById(`store-card-${index}`);
            if (!card) return;
            card.classList.add('highlight');
            setTimeout(() => {
                card.classList.remove('highlight');
            }, 2600);
        }

        function focusStoreCard(index) {
            const card = document.querySelector(`[data-store-index="${index}"]`);
            if (!card) return;
            document.querySelectorAll('.store-card.expanded').forEach(expandedCard => {
                if (expandedCard !== card) {
                    expandedCard.classList.remove('expanded');
                    const expandedDetails = expandedCard.querySelector('.store-details');
                    if (expandedDetails) {
                        expandedDetails.style.maxHeight = '';
                    }
                }
            });
            card.classList.add('expanded');
            const details = card.querySelector('.store-details');
            if (details) {
                details.style.maxHeight = details.scrollHeight + 'px';
            }
            requestAnimationFrame(() => {
                scrollStoreCardIntoView(index);
                highlightStoreCard(index);
            });
        }

        function focusStoreFromDeepLinkIfNeeded() {
            if (!pendingStoreDeepLink || !Array.isArray(window.storesData)) {
                return;
            }
            const targetKey = pendingStoreDeepLink.storeKey;
            if (!targetKey) {
                pendingStoreDeepLink = null;
                return;
            }
            const index = findStoreIndexByKey(targetKey);
            if (index === -1) {
                return;
            }
            pendingStoreDeepLink = null;
            focusStoreCard(index);
        }

        function applyDeepLinkCoordinates(autoSearch = false) {
            if (!deepLinkCoordinates) {
                return false;
            }
            const { lat, lng } = deepLinkCoordinates;
            if (typeof lat !== 'number' || Number.isNaN(lat) ||
                typeof lng !== 'number' || Number.isNaN(lng)) {
                return false;
            }
            const alreadyApplied = deepLinkLocationApplied;
            deepLinkLocationApplied = true;
            currentLocationLabel = 'Shared Location (Start)';
            currentLat = lat;
            currentLng = lng;
            if (!alreadyApplied) {
                const locationStatusEl = document.getElementById('locationStatus');
                if (locationStatusEl) {
                    locationStatusEl.innerHTML = `<span style="color: #17a2b8;">ðŸ“ Using shared location: ${lat.toFixed(4)}, ${lng.toFixed(4)}</span>`;
                }
                const statusMessage = document.getElementById('statusMessage');
                if (statusMessage) {
                    statusMessage.innerHTML = '<div class="status">Exploring this area from a shared link...</div>';
                }
                updateMap(lat, lng, []);
            }
            if (autoSearch) {
                searchStores();
            }
            return true;
        }

        function startInitialLocationFlow(autoSearch = false) {
            if (applyDeepLinkCoordinates(autoSearch)) {
                return;
            }
            getCurrentLocation(autoSearch);
        }

        function showSignatureNoticeOnce(message) {
            const now = Date.now();
            if (now - lastSignatureNotice < 3000) {
                return;
            }
            lastSignatureNotice = now;
            const statusElement = document.getElementById('status');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.display = 'block';
                statusElement.className = 'error fade-in';
                setTimeout(() => {
                    statusElement.textContent = '';
                }, 2500);
            }
        }

        function refreshSignatureDependentControls() {
            const enabled = interactionMode === 'interactive';
            document.querySelectorAll('[data-requires-signature="true"]').forEach(element => {
                const tag = element.tagName;
                const isFormControl = ['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON'].includes(tag);
                if (isFormControl) {
                    element.disabled = !enabled;
                }
                element.classList.toggle('requires-signature-soft-disabled', !enabled);
                if (element.matches('form[data-requires-signature="true"]')) {
                    element.querySelectorAll('input, select, textarea, button').forEach(child => {
                        child.disabled = !enabled;
                        child.classList.toggle('requires-signature-soft-disabled', !enabled);
                    });
                }
            });
            const lockedMessage = document.getElementById('newStoreLockedMessage');
            if (lockedMessage) {
                lockedMessage.style.display = enabled ? 'none' : 'block';
            }
            const toggleBtn = document.getElementById('newStoreToggleBtn');
            if (toggleBtn) {
                if (!toggleBtn.dataset.originalLabel) {
                    toggleBtn.dataset.originalLabel = toggleBtn.textContent;
                }
                toggleBtn.textContent = enabled ? toggleBtn.dataset.originalLabel : 'Requires Signature';
            }
        }

        function setInteractionMode(mode) {
            interactionMode = mode;
            const banner = document.getElementById('signaturePromptBanner');
            if (banner) {
                banner.style.display = mode === 'interactive' ? 'none' : 'block';
            }
            if (mode === 'view-only') {
                setNewStoreCardExpanded(false);
            }
            refreshSignatureDependentControls();
        }

        initializeDeepLinkFromQuery();
        setInteractionMode('view-only');

        function showStoresContent() {
            const contentEl = document.getElementById('storesContent');
            if (contentEl) {
                contentEl.style.display = 'block';
                initializeNewStoreForm();
                
                // After content is shown and map might be initialized, restore map state from URL
                if (mapInitialized) {
                    setTimeout(() => {
                        restoreStateFromURL();
                    }, 200);
                }
            }
        }

        // Map expansion state
        let isMapExpanded = false;
        let mapExpandedBounds = null;
        let boundsChangeTimeout = null;
        let loadedStoreKeys = new Set();
        let isMapLoading = false;
        let isRestoringFromURL = false; // Flag to prevent race conditions during URL state restoration
        let mapInitialized = false; // Flag to track if map is ready

        // Initialize map
        function initMap() {
            if (!map) {
                // Default to San Francisco if location not available
                map = L.map('map').setView([37.7749, -122.4194], 10);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(map);
                
                // Add bounds change listener for lazy loading
                map.on('moveend', handleMapBoundsChange);
                map.on('zoomend', handleMapBoundsChange);
                
                // Mark map as initialized
                mapInitialized = true;
                
                // If we're restoring from URL and map wasn't ready, try again
                if (isRestoringFromURL) {
                    setTimeout(() => {
                        restoreStateFromURL();
                    }, 100);
                }
            }
        }

        // Handle map bounds change for lazy loading
        function handleMapBoundsChange() {
            if (!isMapExpanded || isMapLoading || isRestoringFromURL) return;
            
            // Debounce bounds changes
            clearTimeout(boundsChangeTimeout);
            boundsChangeTimeout = setTimeout(() => {
                loadStoresForBounds();
                // Update URL with new bounds (debounced to avoid too many updates)
                updateURLState(true); // Use replaceState to avoid cluttering history
            }, 500); // Wait 500ms after user stops moving
        }

        // Load stores for current map bounds
        async function loadStoresForBounds() {
            if (!map || !isMapExpanded || isMapLoading) return;
            
            const bounds = map.getBounds();
            // Get selected values from checkboxes
            const statusFilters = getSelectedExpandedStatusFilters();
            const shopTypeFilters = getSelectedExpandedShopTypeFilters();
            
            // Check if we need to load more stores
            const center = bounds.getCenter();
            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            
            // Remove markers that are outside the current bounds
            const neLat = ne.lat;
            const neLng = ne.lng;
            const swLat = sw.lat;
            const swLng = sw.lng;
            
            // Helper function to check if a point is within bounds
            // Note: This uses the bounds from when the function was called
            // For filtering stores, we recalculate bounds inside the filter to ensure accuracy
            const isWithinBounds = (lat, lng) => {
                // Handle longitude wrapping (crossing the 180/-180 meridian)
                if (neLng < swLng) {
                    return lat >= swLat && lat <= neLat && (lng >= swLng || lng <= neLng);
                } else {
                    return lat >= swLat && lat <= neLat && lng >= swLng && lng <= neLng;
                }
            };
            
            // Remove markers outside current bounds
            const markersToRemove = [];
            storeMarkers.forEach((marker, index) => {
                const pos = marker.getLatLng();
                if (!isWithinBounds(pos.lat, pos.lng)) {
                    markersToRemove.push(index);
                    map.removeLayer(marker);
                    // Find and remove from allStoresData and loadedStoreKeys
                    if (window.allStoresData) {
                        const storeIndex = window.allStoresData.findIndex(s => 
                            Math.abs(s.latitude - pos.lat) < 0.0001 && 
                            Math.abs(s.longitude - pos.lng) < 0.0001
                        );
                        if (storeIndex >= 0) {
                            const store = window.allStoresData[storeIndex];
                            // Remove from loadedStoreKeys before removing from allStoresData
                            const storeKey = createStoreKey(store);
                            loadedStoreKeys.delete(storeKey);
                            // Remove from allStoresData
                            window.allStoresData.splice(storeIndex, 1);
                        }
                    }
                }
            });
            
            // Remove markers from array (in reverse order to maintain indices)
            markersToRemove.reverse().forEach(index => {
                storeMarkers.splice(index, 1);
            });
            
            // Update location count after removing markers
            if (isMapExpanded) {
                updateExpandedMapLocationCount();
            }
            
            // Show loading indicator
            showMapLoading(true);
            isMapLoading = true;
            
            try {
                // Validate bounds before sending
                if (isNaN(neLat) || isNaN(neLng) || isNaN(swLat) || isNaN(swLng)) {
                    console.error('Invalid bounds:', { neLat, neLng, swLat, swLng });
                    showMapLoading(false);
                    isMapLoading = false;
                    return;
                }
                
                // Build query with bounds
                const params = new URLSearchParams({
                    lat: center.lat.toString(),
                    lng: center.lng.toString(),
                    limit: '200', // Maximum limit when bounds are provided (backend max: 200 with bounds)
                    ne_lat: neLat.toString(),
                    ne_lng: neLng.toString(),
                    sw_lat: swLat.toString(),
                    sw_lng: swLng.toString()
                });
                
                // Include status filters as array (multiple values)
                if (statusFilters.length > 0) {
                    statusFilters.forEach(status => {
                        params.append('status', status);
                    });
                } else {
                    // If no status selected, send empty to show all
                    params.append('status', '');
                }
                
                // Include shop type filters as array (multiple values)
                if (shopTypeFilters.length > 0) {
                    shopTypeFilters.forEach(shopType => {
                        params.append('shop_type', shopType);
                    });
                } else {
                    // If no shop type selected, send empty to show all
                    params.append('shop_type', '');
                }
                
                const response = await fetch(`${API_URL}?${params.toString()}`);
                const data = await response.json();
                
                console.log('loadStoresForBounds response:', {
                    success: data.success,
                    storeCount: data.stores ? data.stores.length : 0,
                    bounds: { neLat, neLng, swLat, swLng }
                });
                
                if (data.success && data.stores) {
                    // Filter out already loaded stores and add new ones
                    // Also double-check bounds on frontend to ensure we only show stores in viewport
                    const newStores = data.stores.filter(store => {
                        const storeKey = createStoreKey(store);
                        if (loadedStoreKeys.has(storeKey)) {
                            return false;
                        }
                        // Double-check if store is actually within current map bounds
                        const storeLat = parseFloat(store.latitude);
                        const storeLng = parseFloat(store.longitude);
                        if (isNaN(storeLat) || isNaN(storeLng)) {
                            console.log('Skipping store with invalid coordinates:', store.name);
                            return false;
                        }
                        // Get current bounds again (they might have changed)
                        const currentBounds = map.getBounds();
                        const currentNe = currentBounds.getNorthEast();
                        const currentSw = currentBounds.getSouthWest();
                        const currentNeLat = currentNe.lat;
                        const currentNeLng = currentNe.lng;
                        const currentSwLat = currentSw.lat;
                        const currentSwLng = currentSw.lng;
                        
                        // Check if within current bounds
                        let withinBounds;
                        if (currentNeLng < currentSwLng) {
                            // Handle longitude wrapping
                            withinBounds = storeLat >= currentSwLat && storeLat <= currentNeLat && 
                                         (storeLng >= currentSwLng || storeLng <= currentNeLng);
                        } else {
                            withinBounds = storeLat >= currentSwLat && storeLat <= currentNeLat && 
                                         storeLng >= currentSwLng && storeLng <= currentNeLng;
                        }
                        
                        if (!withinBounds) {
                            console.log('Filtering out store outside bounds:', store.name, storeLat, storeLng);
                            return false;
                        }
                        loadedStoreKeys.add(storeKey);
                        return true;
                    });
                    
                    console.log('Filtered new stores:', newStores.length, 'out of', data.stores.length);
                    
                    if (newStores.length > 0) {
                        // Add new markers to map
                        addStoresToMap(newStores);
                    } else if (data.stores && data.stores.length > 0) {
                        // If we got stores from backend but they were all filtered out, log why
                        console.warn('All stores from backend were filtered out. This might indicate a bounds mismatch.');
                    }
                    
                    // Update location count
                    updateExpandedMapLocationCount();
                    
                    // Update route with all visible stores
                    updateExpandedMapRoute();
                } else {
                    // No stores returned from backend
                    console.log('No stores returned from backend. Response:', data);
                    // Update location count even if no new stores
                    updateExpandedMapLocationCount();
                }
            } catch (error) {
                console.error('Error loading stores for bounds:', error);
            } finally {
                showMapLoading(false);
                isMapLoading = false;
            }
        }

        // Add stores to map without clearing existing markers
        function addStoresToMap(stores) {
            if (!map || !stores || stores.length === 0) return;
            
            // Store in allStoresData for route calculation
            if (!window.allStoresData) {
                window.allStoresData = [];
            }
            
            stores.forEach((store) => {
                // Check if marker already exists
                const existingMarker = storeMarkers.find(m => {
                    const pos = m.getLatLng();
                    return Math.abs(pos.lat - store.latitude) < 0.0001 && 
                           Math.abs(pos.lng - store.longitude) < 0.0001;
                });
                
                if (existingMarker) return;
                
                // Add to allStoresData if not already there
                const existing = window.allStoresData.find(s => 
                    Math.abs(s.latitude - store.latitude) < 0.0001 && 
                    Math.abs(s.longitude - store.longitude) < 0.0001
                );
                if (!existing) {
                    window.allStoresData.push(store);
                    // Update location count when stores are added
                    if (isMapExpanded) {
                        updateExpandedMapLocationCount();
                    }
                }
                
                const mapsQueryParts = [
                    store.name || '',
                    store.address || '',
                    store.city || '',
                    store.state || ''
                ].join(' ').trim();
                const mapsQuery = mapsQueryParts ? encodeURIComponent(mapsQueryParts) : '';
                const mapsUrl = mapsQuery
                    ? `https://www.google.com/maps/search/?api=1&query=${mapsQuery}`
                    : `https://www.google.com/maps/search/?api=1&query=${store.latitude},${store.longitude}`;

                const marker = L.marker([store.latitude, store.longitude], {
                    icon: createNumberedIcon(storeMarkers.length + 1, 'blue')
                })
                .addTo(map)
                .bindPopup(`
                    <strong>${escapeHtml(store.name)}</strong><br>
                    ${escapeHtml(store.address || '')}${store.city ? ', ' + escapeHtml(store.city) : ''}${store.state ? ', ' + escapeHtml(store.state) : ''}<br>
                    <strong>Distance:</strong> ${store.distance ? store.distance.toFixed(1) : 'N/A'} miles<br>
                    <a href="${mapsUrl}" target="_blank" style="color: #007bff; text-decoration: none; margin-right: 0.5rem;">ðŸ“ View on Google Maps</a>
                    ${store.instagram ? `<a href="${escapeHtml(store.instagram)}" target="_blank" style="color: #E4405F; text-decoration: none;">ðŸ“· View Instagram</a>` : ''}
                `);

                storeMarkers.push(marker);
            });
        }

        // Show/hide map loading indicator
        function showMapLoading(show) {
            const indicator = document.getElementById('mapLoadingIndicator');
            if (indicator) {
                if (show) {
                    indicator.classList.add('show');
                } else {
                    indicator.classList.remove('show');
                }
            }
        }

        // Expand map to full screen
        function expandMap(skipURLUpdate = false) {
            const mapEl = document.getElementById('map');
            const expandBtn = document.getElementById('expandMapBtn');
            const collapseBtn = document.getElementById('collapseMapBtn');
            const header = document.getElementById('expandedMapHeader');
            const overlay = document.getElementById('expandedMapOverlay');
            
            // Prevent race conditions: don't expand if already expanding/expanded
            // Allow expansion during restoration if skipURLUpdate is true (called from restoreStateFromURL)
            // For normal user interaction, only check if map exists (mapInitialized check is too strict)
            if (!mapEl) {
                console.warn('expandMap: map element not found');
                return;
            }
            
            if (!map) {
                console.warn('expandMap: map object not found');
                return;
            }
            
            if (isMapExpanded) {
                // Already expanded, nothing to do
                return;
            }
            
            // Additional check: if restoring from URL, only allow if skipURLUpdate is true
            if (isRestoringFromURL && !skipURLUpdate) {
                console.warn('expandMap: restoration in progress, skipping');
                return;
            }
            
            // Ensure map is initialized (but don't block if it's not - it will be initialized)
            if (!mapInitialized) {
                initMap();
                // Wait a bit for map to be fully initialized
                if (!mapInitialized) {
                    setTimeout(() => {
                        if (map && !isMapExpanded) {
                            expandMap(skipURLUpdate);
                        }
                    }, 200);
                    return;
                }
            }
            
            // Save current bounds for restoration
            mapExpandedBounds = map.getBounds();
            
            // Update UI
            mapEl.classList.add('expanded');
            if (expandBtn) expandBtn.style.display = 'none';
            if (collapseBtn) collapseBtn.style.display = 'flex';
            if (header) header.classList.add('show');
            if (overlay) overlay.classList.add('show');
            
            // Sync checkbox states from normal view to expanded view
            syncCheckboxes('.status-filter-checkbox', '.expanded-status-filter-checkbox');
            syncCheckboxes('.shop-type-filter-checkbox', '.expanded-shop-type-filter-checkbox');
            
            isMapExpanded = true;
            loadedStoreKeys.clear();
            
            // Initialize allStoresData if needed
            if (!window.allStoresData) {
                window.allStoresData = [];
            }
            
            // Invalidate map size and trigger resize
            setTimeout(() => {
                map.invalidateSize();
                // Update location count immediately
                updateExpandedMapLocationCount();
                // Load stores for current view (but skip if restoring from URL - bounds will be set later)
                if (!skipURLUpdate) {
                    // Only load stores if not restoring from URL
                    // When restoring, loadStoresForBounds will be called after bounds are set
                    loadStoresForBounds();
                }
                // Update route if we already have stores
                if (storeMarkers.length > 0) {
                    updateExpandedMapRoute();
                }
                // Update URL with expanded state and bounds (unless called from URL load)
                if (!skipURLUpdate) {
                    updateURLState(true);
                }
            }, 100);
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }

        // Collapse map to normal view
        function collapseMap() {
            const mapEl = document.getElementById('map');
            const expandBtn = document.getElementById('expandMapBtn');
            const collapseBtn = document.getElementById('collapseMapBtn');
            const header = document.getElementById('expandedMapHeader');
            const overlay = document.getElementById('expandedMapOverlay');
            
            // Prevent race conditions: don't collapse if not expanded
            // Allow collapse even during restoration (user might want to cancel)
            if (!mapEl || !map || !isMapExpanded) return;
            
            // Update UI
            mapEl.classList.remove('expanded');
            if (expandBtn) expandBtn.style.display = 'flex';
            if (collapseBtn) collapseBtn.style.display = 'none';
            if (header) header.classList.remove('show');
            if (overlay) overlay.classList.remove('show');
            
            isMapExpanded = false;
            
            // If we have stores from expanded view, display them in the list
            if (window.allStoresData && window.allStoresData.length > 0 && currentLat && currentLng) {
                // Calculate distances from user location for all stores
                const storesWithDistances = window.allStoresData.map(store => {
                    const distance = calculateDistance(
                        currentLat, 
                        currentLng, 
                        parseFloat(store.latitude), 
                        parseFloat(store.longitude)
                    );
                    return {
                        ...store,
                        distance: distance
                    };
                });
                
                // Solve TSP to get optimal route (starting from user location, not nearest store)
                const orderedStores = solveTSP(currentLat, currentLng, storesWithDistances, false);
                
                // Store ordered stores globally
                window.orderedStoresData = orderedStores;
                
                // Calculate total route distance
                const totalDistance = orderedStores.reduce((sum, store) => sum + (store.routeDistance || 0), 0);
                window.totalRouteDistance = totalDistance;
                
                // Display stores in the list
                displayStores(orderedStores, '');
                
                // Update map to show route with user location
                updateMap(currentLat, currentLng, orderedStores);
            }
            
            // Restore map size
            setTimeout(() => {
                map.invalidateSize();
                
                // Restore to route view if we have stores
                if (window.orderedStoresData && window.orderedStoresData.length > 0 && currentLat && currentLng) {
                    // Restore to show route
                    const allMarkers = userMarker ? [userMarker, ...storeMarkers] : storeMarkers;
                    if (allMarkers.length > 0) {
                        const group = new L.featureGroup(allMarkers);
                        map.fitBounds(group.getBounds().pad(0.1));
                    } else {
                        map.setView([currentLat, currentLng], 13);
                    }
                } else if (currentLat && currentLng) {
                    map.setView([currentLat, currentLng], 13);
                }
            }, 100);
            
            // Restore body scroll
            document.body.style.overflow = '';
            
            // Update URL (remove bounds when collapsed)
            updateURLState(true);
        }

        // Toggle expanded map panel visibility
        function toggleExpandedMapPanel() {
            const header = document.getElementById('expandedMapHeader');
            const mapEl = document.getElementById('map');
            const toggleIcon = document.getElementById('togglePanelIcon');
            
            if (!header || !mapEl) return;
            
            const isCollapsed = header.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Show panel
                header.classList.remove('collapsed');
                mapEl.classList.remove('panel-hidden');
                toggleIcon.textContent = 'â–¼';
            } else {
                // Hide panel
                header.classList.add('collapsed');
                mapEl.classList.add('panel-hidden');
                toggleIcon.textContent = 'â–²';
            }
            
            // Invalidate map size to trigger resize
            setTimeout(() => {
                if (map) {
                    map.invalidateSize();
                }
            }, 100);
            
            // Update URL state to save panel collapsed state
            updateURLState(true);
        }
        
        // Initialize map controls
        function initMapControls() {
            const expandBtn = document.getElementById('expandMapBtn');
            const collapseBtn = document.getElementById('collapseMapBtn');
            const closeBtn = document.getElementById('closeExpandedMapBtn');
            const togglePanelBtn = document.getElementById('togglePanelBtn');
            if (expandBtn) {
                expandBtn.addEventListener('click', expandMap);
                // Show expand button when map has content
                if (map && storeMarkers.length > 0) {
                    expandBtn.style.display = 'flex';
                }
            }
            
            if (collapseBtn) {
                collapseBtn.addEventListener('click', collapseMap);
            }
            
            if (closeBtn) {
                closeBtn.addEventListener('click', collapseMap);
            }
            if (togglePanelBtn) {
                togglePanelBtn.addEventListener('click', toggleExpandedMapPanel);
            }
            
            // Add event listeners for expanded view checkboxes
            // Note: These are added dynamically when checkboxes are created, so we'll add them in a way that works
            // We'll use event delegation or add listeners after DOM is ready
            setTimeout(() => {
                document.querySelectorAll('.expanded-status-filter-checkbox').forEach(checkbox => {
                    // Remove any existing listeners by cloning
                    const newCheckbox = checkbox.cloneNode(true);
                    checkbox.parentNode.replaceChild(newCheckbox, checkbox);
                    
                    newCheckbox.addEventListener('change', function() {
                        // Sync to normal view
                        syncCheckboxes('.expanded-status-filter-checkbox', '.status-filter-checkbox');
                        
                        // Save filter states
                        saveFilterStates();
                        
                        // Update counts
                        updateFilterCounts();
                        
                        // Clear loaded stores and reload
                        loadedStoreKeys.clear();
                        window.allStoresData = [];
                        storeMarkers.forEach(marker => map.removeLayer(marker));
                        storeMarkers = [];
                        if (window.routeLine) {
                            map.removeLayer(window.routeLine);
                            window.routeLine = null;
                        }
                        
                        // Reload stores for current bounds
                        loadStoresForBounds();
                    });
                });
                
                document.querySelectorAll('.expanded-shop-type-filter-checkbox').forEach(checkbox => {
                    // Remove any existing listeners by cloning
                    const newCheckbox = checkbox.cloneNode(true);
                    checkbox.parentNode.replaceChild(newCheckbox, checkbox);
                    
                    newCheckbox.addEventListener('change', function() {
                        // Sync to normal view
                        syncCheckboxes('.expanded-shop-type-filter-checkbox', '.shop-type-filter-checkbox');
                        
                        // Save filter states
                        saveFilterStates();
                        
                        // Update counts
                        updateFilterCounts();
                        
                        // Clear loaded stores and reload
                        loadedStoreKeys.clear();
                        window.allStoresData = [];
                        storeMarkers.forEach(marker => map.removeLayer(marker));
                        storeMarkers = [];
                        if (window.routeLine) {
                            map.removeLayer(window.routeLine);
                            window.routeLine = null;
                        }
                        
                        // Reload stores for current bounds
                        loadStoresForBounds();
                    });
                });
            }, 100);
        }

        // Update location count in expanded map header
        function updateExpandedMapLocationCount() {
            const countEl = document.getElementById('expandedMapLocationCountText');
            if (countEl && window.allStoresData) {
                const count = window.allStoresData.length;
                countEl.textContent = `${count} location${count !== 1 ? 's' : ''} loaded`;
            }
        }

        // Calculate distance between two points (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3959; // Earth's radius in miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Solve TSP using nearest neighbor heuristic + 2-opt improvement
        // If startFromNearestStore is true, the route starts from the store closest to startLat/startLng
        // Otherwise, it starts from the user location
        function solveTSP(startLat, startLng, stores, startFromNearestStore = false) {
            if (stores.length === 0) return [];

            // Create distance matrix
            const n = stores.length;
            const distances = [];
            for (let i = 0; i < n; i++) {
                distances[i] = [];
                for (let j = 0; j < n; j++) {
                    distances[i][j] = calculateDistance(
                        stores[i].latitude, stores[i].longitude,
                        stores[j].latitude, stores[j].longitude
                    );
                }
            }

            // Nearest neighbor heuristic starting from user location or nearest store
            const startDistances = stores.map((store, i) => ({
                index: i,
                distance: calculateDistance(startLat, startLng, store.latitude, store.longitude)
            }));
            startDistances.sort((a, b) => a.distance - b.distance);

            // If starting from nearest store, use that store as the first point
            const firstStoreIndex = startFromNearestStore ? startDistances[0].index : null;

            let route;
            let unvisited = new Set();
            
            if (startFromNearestStore && firstStoreIndex !== null) {
                // Start from the nearest store
                route = [firstStoreIndex];
                for (let i = 0; i < n; i++) {
                    if (i !== firstStoreIndex) {
                        unvisited.add(i);
                    }
                }
            } else {
                // Start from user location (original behavior)
                route = [startDistances[0].index];
            for (let i = 1; i < n; i++) {
                unvisited.add(startDistances[i].index);
                }
            }

            // Build route using nearest neighbor
            while (unvisited.size > 0) {
                let current = route[route.length - 1];
                let nearest = null;
                let minDist = Infinity;

                unvisited.forEach(next => {
                    const dist = distances[current][next];
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = next;
                    }
                });

                route.push(nearest);
                unvisited.delete(nearest);
            }

            // 2-opt improvement for path (not cycle - no return to origin)
            let improved = true;
            while (improved) {
                improved = false;
                for (let i = 0; i < route.length - 1; i++) {
                    for (let j = i + 2; j < route.length; j++) {
                        // For path TSP, we don't connect back to start
                        // Calculate distance before and after swap
                        let distBefore = distances[route[i]][route[i + 1]];
                        let distAfter = distances[route[i]][route[j]];
                        
                        // Add the edge after j if it exists
                        if (j < route.length - 1) {
                            distBefore += distances[route[j]][route[j + 1]];
                            distAfter += distances[route[i + 1]][route[j + 1]];
                        }
                        
                        if (distAfter < distBefore) {
                            // Reverse segment between i+1 and j
                            const segment = route.slice(i + 1, j + 1).reverse();
                            route.splice(i + 1, j - i, ...segment);
                            improved = true;
                        }
                    }
                }
            }

            // Reorder stores and calculate cumulative distances
            const orderedStores = route.map((idx, orderIndex) => {
                const store = stores[idx];
                let prevLat, prevLng;
                
                if (orderIndex === 0) {
                    if (startFromNearestStore) {
                        // First store - no previous point, distance is 0
                        prevLat = store.latitude;
                        prevLng = store.longitude;
                    } else {
                        // Start from user location
                        prevLat = startLat;
                        prevLng = startLng;
                    }
                } else {
                    prevLat = stores[route[orderIndex - 1]].latitude;
                    prevLng = stores[route[orderIndex - 1]].longitude;
                }
                
                const routeDistance = orderIndex === 0 && startFromNearestStore ? 0 : 
                    calculateDistance(prevLat, prevLng, store.latitude, store.longitude);
                
                return {
                    ...store,
                    routeOrder: orderIndex + 1,
                    routeDistance: routeDistance
                };
            });

            return orderedStores;
        }
        
        // Update route in expanded view with all visible stores
        function updateExpandedMapRoute() {
            if (!isMapExpanded || !map || !currentLat || !currentLng) return;
            
            // Get all visible store markers
            const visibleStores = storeMarkers.map(marker => {
                const pos = marker.getLatLng();
                // Find the store data from window.orderedStoresData or reconstruct from marker
                const storeData = window.allStoresData?.find(s => 
                    Math.abs(s.latitude - pos.lat) < 0.0001 && 
                    Math.abs(s.longitude - pos.lng) < 0.0001
                );
                return storeData || {
                    latitude: pos.lat,
                    longitude: pos.lng,
                    name: '',
                    address: '',
                    city: '',
                    state: ''
                };
            });
            
            if (visibleStores.length === 0) return;
            
            // Solve TSP starting from nearest store
            const orderedStores = solveTSP(currentLat, currentLng, visibleStores, true);
            
            // Update marker numbers based on new route order
            orderedStores.forEach((store, index) => {
                const marker = storeMarkers.find(m => {
                    const pos = m.getLatLng();
                    return Math.abs(pos.lat - store.latitude) < 0.0001 && 
                           Math.abs(pos.lng - store.longitude) < 0.0001;
                });
                if (marker) {
                    marker.setIcon(createNumberedIcon(index + 1, 'blue'));
                }
            });
            
            // Draw route line (store to store, not from user location)
            const routeCoordinates = orderedStores.map(s => [s.latitude, s.longitude]);
            if (window.routeLine) {
                map.removeLayer(window.routeLine);
            }
            window.routeLine = L.polyline(routeCoordinates, {
                color: '#007bff',
                weight: 3,
                opacity: 0.7,
                dashArray: '10, 10'
            }).addTo(map);
            
            // Store ordered stores for reference
            window.expandedOrderedStores = orderedStores;
        }

        // Create numbered marker icon using DivIcon
        function createNumberedIcon(number, color = 'blue') {
            const iconHtml = `
                <div style="
                    background-color: ${color === 'blue' ? '#3388ff' : '#ff3333'};
                    width: 30px;
                    height: 30px;
                    border-radius: 50%;
                    border: 3px solid white;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                    font-size: 14px;
                    font-family: Arial, sans-serif;
                ">${number}</div>
            `;
            
            return L.divIcon({
                html: iconHtml,
                className: 'numbered-marker',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
        }

        // Update map with user location and stores (with TSP ordering)
        function updateMap(lat, lng, stores = []) {
            currentLat = lat;
            currentLng = lng;
            
            if (!map) {
                initMap();
            }

            // Only clear markers if not in expanded mode (to preserve lazy-loaded stores)
            if (!isMapExpanded) {
            // Clear existing markers
            if (userMarker) {
                map.removeLayer(userMarker);
            }
            storeMarkers.forEach(marker => map.removeLayer(marker));
            storeMarkers = [];
                loadedStoreKeys.clear();
            } else {
                // In expanded mode, only clear user marker if needed
                if (userMarker) {
                    map.removeLayer(userMarker);
                }
            }

            // Add user location marker
            userMarker = L.marker([lat, lng], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map)
            .bindPopup(`<strong>${currentLocationLabel}</strong><br>` + lat.toFixed(6) + ', ' + lng.toFixed(6));

            if (stores.length > 0) {
                // Solve TSP to get optimal route
                const orderedStores = solveTSP(lat, lng, stores);
                
                // Store ordered stores globally for display
                window.orderedStoresData = orderedStores;

                // Calculate total route distance
                const totalDistance = orderedStores.reduce((sum, store) => sum + (store.routeDistance || 0), 0);

                // Mark stores as loaded
                orderedStores.forEach(store => {
                    const storeKey = createStoreKey(store);
                    loadedStoreKeys.add(storeKey);
                });
                
                // Store all stores data for expanded view route calculation
                if (!window.allStoresData) {
                    window.allStoresData = [];
                }
                orderedStores.forEach(store => {
                    const existing = window.allStoresData.find(s => 
                        Math.abs(s.latitude - store.latitude) < 0.0001 && 
                        Math.abs(s.longitude - store.longitude) < 0.0001
                    );
                    if (!existing) {
                        window.allStoresData.push(store);
                    }
                });

                // Add store markers with numbers
                // In expanded mode, use expanded route order; otherwise use normal order
                const storesToDisplay = isMapExpanded && window.expandedOrderedStores ? 
                    window.expandedOrderedStores : orderedStores;
                
                storesToDisplay.forEach((store) => {
                    // Check if marker already exists (for expanded mode)
                    const existingMarker = storeMarkers.find(m => {
                        const pos = m.getLatLng();
                        return Math.abs(pos.lat - store.latitude) < 0.0001 && 
                               Math.abs(pos.lng - store.longitude) < 0.0001;
                    });
                    
                    if (existingMarker) return;

                    const mapsQueryParts = [
                        store.name || '',
                        store.address || '',
                        store.city || '',
                        store.state || ''
                    ].join(' ').trim();
                    const mapsQuery = mapsQueryParts ? encodeURIComponent(mapsQueryParts) : '';
                    const mapsUrl = mapsQuery
                        ? `https://www.google.com/maps/search/?api=1&query=${mapsQuery}`
                        : `https://www.google.com/maps/search/?api=1&query=${store.latitude},${store.longitude}`;

                    const marker = L.marker([store.latitude, store.longitude], {
                        icon: createNumberedIcon(store.routeOrder, 'blue')
                    })
                    .addTo(map)
                    .bindPopup(`
                        <strong>Stop ${store.routeOrder}: ${escapeHtml(store.name)}</strong><br>
                        ${escapeHtml(store.address || '')}${store.city ? ', ' + escapeHtml(store.city) : ''}${store.state ? ', ' + escapeHtml(store.state) : ''}<br>
                        <strong>Distance from previous:</strong> ${store.routeDistance ? store.routeDistance.toFixed(1) : store.distance} miles<br>             
                        <strong>Distance from you:</strong> ${store.distance} miles<br>                                                                         
                        <a href="${mapsUrl}" target="_blank" style="color: #007bff; text-decoration: none; margin-right: 0.5rem;">ðŸ“ View on Google Maps</a>
                        ${store.instagram ? `<a href="${escapeHtml(store.instagram)}" target="_blank" style="color: #E4405F; text-decoration: none;">ðŸ“· View Instagram</a>` : ''}
                    `);

                    storeMarkers.push(marker);
                });

                // Draw route line
                if (isMapExpanded) {
                    // In expanded mode, route starts from nearest store (not user location)
                    const expandedOrderedStores = solveTSP(lat, lng, stores, true);
                    const routeCoordinates = expandedOrderedStores.map(s => [s.latitude, s.longitude]);
                    if (window.routeLine) {
                        map.removeLayer(window.routeLine);
                    }
                    window.routeLine = L.polyline(routeCoordinates, {
                        color: '#007bff',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(map);
                    window.expandedOrderedStores = expandedOrderedStores;
                } else {
                    // Normal mode: route starts from user location
                const routeCoordinates = [[lat, lng], ...orderedStores.map(s => [s.latitude, s.longitude])];
                if (window.routeLine) {
                    map.removeLayer(window.routeLine);
                }
                window.routeLine = L.polyline(routeCoordinates, {
                    color: '#007bff',
                    weight: 3,
                    opacity: 0.7,
                    dashArray: '10, 10'
                }).addTo(map);
                }

                // Fit map to show all markers (only if not in expanded mode)
                if (!isMapExpanded) {
                    // Ensure map is properly sized before fitting bounds
                    map.invalidateSize();
                    setTimeout(() => {
                        if (map && userMarker && storeMarkers.length > 0) {
                            const group = new L.featureGroup([userMarker, ...storeMarkers]);
                            map.fitBounds(group.getBounds().pad(0.1));
                        }
                    }, 100);
                }
                
                // Store total route distance for display
                window.totalRouteDistance = totalDistance;
                
                // Show expand button
                const expandBtn = document.getElementById('expandMapBtn');
                if (expandBtn) {
                    expandBtn.style.display = 'flex';
                }
            } else {
                // Don't change map view if we're restoring from URL with bounds
                if (!isMapExpanded && !isRestoringFromURL) {
                    map.setView([lat, lng], 13);
                }
                // Hide expand button if no stores
                const expandBtn = document.getElementById('expandMapBtn');
                if (expandBtn) {
                    expandBtn.style.display = 'none';
                }
            }
        }

        // Digital signature verification on page load
        window.addEventListener('load', async () => {
            // Initialize map controls
            initMapControls();
            
            const publicKey = localStorage.getItem('publicKey');
            const statusElement = document.getElementById('status');
            statusElement.textContent = 'Verifying your digital signature...';
            statusElement.className = 'loading fade-in';

            if (!publicKey) {
                statusElement.textContent = 'No digital signature found. Viewing in read-only mode.';
                statusElement.className = 'error fade-in';
                showStoresContent();
                initMap();
                
                // Load state from URL first (filters, location, map state)
                loadStateFromURL();
                
                // Update status description based on selected checkboxes
                const selected = getSelectedStatusFilters();
                if (selected.length === 1) {
                    updateStatusDescription(selected[0]);
                } else if (selected.length > 1) {
                    updateStatusDescription('Multiple');
                } else {
                    updateStatusDescription('');
                }
                setInteractionMode('view-only');
                
                // Restore map state from URL if available, otherwise start location flow
                setTimeout(() => {
                    if (mapInitialized) {
                        restoreStateFromURL();
                        // If no URL state was restored, start location flow
                        const params = new URLSearchParams(window.location.search);
                        const hasURLState = params.get('lat') && params.get('lng');
                        if (!hasURLState) {
                            startInitialLocationFlow(true);
                        }
                    } else {
                        // Wait for map to initialize, then restore or start location flow
                        const checkMap = setInterval(() => {
                            if (mapInitialized) {
                                clearInterval(checkMap);
                                restoreStateFromURL();
                                const params = new URLSearchParams(window.location.search);
                                const hasURLState = params.get('lat') && params.get('lng');
                                if (!hasURLState) {
                                    startInitialLocationFlow(true);
                                }
                            }
                        }, 100);
                        // Timeout after 2 seconds
                        setTimeout(() => clearInterval(checkMap), 2000);
                    }
                }, 100);
                return;
            }

            try {
                // Add timeout to fetch request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch(`${SIGNATURE_VERIFY_API}?signature=${encodeURIComponent(publicKey)}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();

                if (data.error) {
                    if (data.error.includes('No matching')) {
                        statusElement.innerHTML = 'Your digital signature is not registered. <a href="./create_signature.html">Please register it first</a>.';
                        statusElement.className = 'error fade-in';
                        showStoresContent();
                        initMap();
                        
                        // Load state from URL first (filters, location, map state)
                        loadStateFromURL();
                        
                        // Update status description based on selected checkboxes
                        const selected = getSelectedStatusFilters();
                        if (selected.length === 1) {
                            updateStatusDescription(selected[0]);
                        } else if (selected.length > 1) {
                            updateStatusDescription('Multiple');
                        } else {
                            updateStatusDescription('');
                        }
                        setInteractionMode('view-only');
                        
                        // Restore map state from URL if available, otherwise start location flow
                        setTimeout(() => {
                            if (mapInitialized) {
                                restoreStateFromURL();
                                const params = new URLSearchParams(window.location.search);
                                const hasURLState = params.get('lat') && params.get('lng');
                                if (!hasURLState) {
                                    startInitialLocationFlow(true);
                                }
                            } else {
                                const checkMap = setInterval(() => {
                                    if (mapInitialized) {
                                        clearInterval(checkMap);
                                        restoreStateFromURL();
                                        const params = new URLSearchParams(window.location.search);
                                        const hasURLState = params.get('lat') && params.get('lng');
                                        if (!hasURLState) {
                                            startInitialLocationFlow(true);
                                        }
                                    }
                                }, 100);
                                setTimeout(() => clearInterval(checkMap), 2000);
                            }
                        }, 100);
                        return;
                    } else {
                        statusElement.textContent = 'Error: ' + data.error;
                        statusElement.className = 'error fade-in';
                        // Still allow access if verification fails with other errors
                        showStoresContent();                                                                                                                   
                        initMap();
                        
                        // Load state from URL first (filters, location, map state)
                        loadStateFromURL();
                        
                        setInteractionMode('view-only');
                        
                        // Restore map state from URL if available, otherwise start location flow
                        setTimeout(() => {
                            if (mapInitialized) {
                                restoreStateFromURL();
                                const params = new URLSearchParams(window.location.search);
                                const hasURLState = params.get('lat') && params.get('lng');
                                if (!hasURLState) {
                                    startInitialLocationFlow(true);
                                }
                            } else {
                                const checkMap = setInterval(() => {
                                    if (mapInitialized) {
                                        clearInterval(checkMap);
                                        restoreStateFromURL();
                                        const params = new URLSearchParams(window.location.search);
                                        const hasURLState = params.get('lat') && params.get('lng');
                                        if (!hasURLState) {
                                            startInitialLocationFlow(true);
                                        }
                                    }
                                }, 100);
                                setTimeout(() => clearInterval(checkMap), 2000);
                            }
                        }, 100);
                        return;
                    }
                }

                contributorName = data.contributor_name;
                document.getElementById('welcome').textContent = `Welcome back, ${contributorName}!`;
                document.getElementById('welcome').style.display = 'block';
                showStoresContent();                                                                                                                           
                statusElement.textContent = 'Signature verified successfully';
                statusElement.className = 'status fade-in';
                setInteractionMode('interactive');

                // Hide status after 3 seconds
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 3000);

                // Initialize map
                initMap();
                
                // Initialize status description
                // Update status description based on selected checkboxes
                const selected = getSelectedStatusFilters();
                if (selected.length === 1) {
                    updateStatusDescription(selected[0]);
                } else if (selected.length > 1) {
                    updateStatusDescription('Multiple');
                } else {
                    updateStatusDescription('');
                }
                
                // Now proceed with location detection and auto-search
                startInitialLocationFlow(true);
            } catch (error) {
                console.error('Signature verification error:', error);
                
                // If it's a network error, allow access but show warning
                if (error.name === 'AbortError' || error.message.includes('fetch') || error.message.includes('network')) {
                    statusElement.innerHTML = 'âš ï¸ Could not verify signature (network error). Access granted with limited functionality.';
                    statusElement.className = 'error fade-in';
                    // Still allow access
                    showStoresContent();                                                                                                                       
                    initMap();
                    
                    // Load state from URL first (filters, location, map state)
                    loadStateFromURL();
                    
                    // Update status description based on selected checkboxes
                    const selected = getSelectedStatusFilters();
                    if (selected.length === 1) {
                        updateStatusDescription(selected[0]);
                    } else if (selected.length > 1) {
                        updateStatusDescription('Multiple');
                    } else {
                        updateStatusDescription('');
                    }
                    setInteractionMode('view-only');
                    
                    // Restore map state from URL if available, otherwise start location flow
                    setTimeout(() => {
                        if (mapInitialized) {
                            restoreStateFromURL();
                            const params = new URLSearchParams(window.location.search);
                            const hasURLState = params.get('lat') && params.get('lng');
                            if (!hasURLState) {
                                startInitialLocationFlow(true);
                            }
                        } else {
                            const checkMap = setInterval(() => {
                                if (mapInitialized) {
                                    clearInterval(checkMap);
                                    restoreStateFromURL();
                                    const params = new URLSearchParams(window.location.search);
                                    const hasURLState = params.get('lat') && params.get('lng');
                                    if (!hasURLState) {
                                        startInitialLocationFlow(true);
                                    }
                                }
                            }, 100);
                            setTimeout(() => clearInterval(checkMap), 2000);
                        }
                    }, 100);
                    
                    // Hide warning after 5 seconds
                    setTimeout(() => {
                        statusElement.style.display = 'none';
                    }, 5000);
                } else {
                    statusElement.textContent = 'Error verifying signature: ' + error.message;
                    statusElement.className = 'error fade-in';
                    // Still allow access for other errors
                    showStoresContent();                                                                                                                       
                    initMap();
                    
                    // Load state from URL first (filters, location, map state)
                    loadStateFromURL();
                    
                    // Update status description based on selected checkboxes
                    const selected = getSelectedStatusFilters();
                    if (selected.length === 1) {
                        updateStatusDescription(selected[0]);
                    } else if (selected.length > 1) {
                        updateStatusDescription('Multiple');
                    } else {
                        updateStatusDescription('');
                    }
                    setInteractionMode('view-only');
                    
                    // Restore map state from URL if available, otherwise start location flow
                    setTimeout(() => {
                        if (mapInitialized) {
                            restoreStateFromURL();
                            const params = new URLSearchParams(window.location.search);
                            const hasURLState = params.get('lat') && params.get('lng');
                            if (!hasURLState) {
                                startInitialLocationFlow(true);
                            }
                        } else {
                            const checkMap = setInterval(() => {
                                if (mapInitialized) {
                                    clearInterval(checkMap);
                                    restoreStateFromURL();
                                    const params = new URLSearchParams(window.location.search);
                                    const hasURLState = params.get('lat') && params.get('lng');
                                    if (!hasURLState) {
                                        startInitialLocationFlow(true);
                                    }
                                }
                            }, 100);
                            setTimeout(() => clearInterval(checkMap), 2000);
                        }
                    }, 100);
                }
            }
        });

        // Function to get current location
        function getCurrentLocation(autoSearch = false) {
            const locationStatusEl = document.getElementById('locationStatus');
            const statusMessage = document.getElementById('statusMessage');
            
            if (!navigator.geolocation) {
                const errorMsg = 'Geolocation is not supported by your browser.';
                if (locationStatusEl) {
                    locationStatusEl.innerHTML = `<span style="color: #dc3545;">âŒ ${errorMsg}</span>`;
                }
                if (statusMessage) {
                    statusMessage.innerHTML = `<div class="error">${errorMsg}</div>`;
                }
                return;
            }
            
            // Update location status
            if (locationStatusEl) {
                locationStatusEl.innerHTML = '<span style="color: #007bff;">ðŸ“ Detecting your location...</span>';
            }
            if (statusMessage) {
                statusMessage.innerHTML = '<div class="loading"><div class="spinner"></div>Getting your location...</div>';
            }
            
            // Set a timeout to prevent hanging
            const timeoutId = setTimeout(() => {
                if (locationStatusEl) {
                    locationStatusEl.innerHTML = `<span style="color: #dc3545;">âŒ Location request timed out. Please try again or use "Use Current Location" button.</span>`;
                }
                if (statusMessage) {
                    statusMessage.innerHTML = `<div class="error">Location request timed out. Please try again or use "Use Current Location" button.</div>`;
                }
            }, 15000); // 15 second timeout
            
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    clearTimeout(timeoutId);
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    currentLocationLabel = 'Your Location (Start)';
                    currentLat = lat;
                    currentLng = lng;
                    
                    // Update location status
                    if (locationStatusEl) {
                        locationStatusEl.innerHTML = `<span style="color: #28a745;">âœ… Location detected: ${lat.toFixed(4)}, ${lng.toFixed(4)}</span>`;
                    }
                    
                    // Update map with user location
                    updateMap(lat, lng, []);
                    
                    // Update URL with new location
                    updateURLState(true);
                    
                    if (autoSearch) {
                        // Automatically search after getting location
                        searchStores();
                    } else {
                        if (statusMessage) {
                            statusMessage.innerHTML = '<div class="status">Location found! Click "Find Nearby Stores" to search.</div>';
                        }
                    }
                },
                function(error) {
                    clearTimeout(timeoutId);
                    let errorMsg = 'Unknown error';
                    if (error.code === 1) {
                        errorMsg = 'Permission denied. Please allow location access and try again.';
                    } else if (error.code === 2) {
                        errorMsg = 'Location unavailable. Please check your device settings.';
                    } else if (error.code === 3) {
                        errorMsg = 'Location request timed out. Please try again.';
                    } else {
                        errorMsg = error.message || 'Unable to get location';
                    }
                    if (locationStatusEl) {
                        locationStatusEl.innerHTML = `<span style="color: #dc3545;">âŒ Error: ${errorMsg}</span>`;
                    }
                    if (statusMessage) {
                        statusMessage.innerHTML = `<div class="error">Error getting location: ${errorMsg}</div>`;
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 15000, // 15 second timeout
                    maximumAge: 0 // Don't use cached location
                }
            );
        }

        // Note: Location detection is now triggered after signature verification

        // Manual location button (doesn't auto-search, just updates location)
        document.getElementById('useCurrentLocation').addEventListener('click', function() {
            getCurrentLocation(false); // false = don't auto-search, just update location
        });

        // Auto-update when status filter changes
        // Function to update filter count badges and summaries
        function updateFilterCounts() {
            const statusSelected = getSelectedStatusFilters();
            const shopTypeSelected = getSelectedShopTypeFilters();
            
            const statusCountEl = document.getElementById('statusFilterCount');
            const shopTypeCountEl = document.getElementById('shopTypeFilterCount');
            const statusSummaryEl = document.getElementById('statusFilterSummary');
            const shopTypeSummaryEl = document.getElementById('shopTypeFilterSummary');
            
            if (statusCountEl) {
                const count = statusSelected.length;
                const total = document.querySelectorAll('.status-filter-checkbox').length;
                if (count === 0) {
                    statusCountEl.textContent = 'All';
                    statusCountEl.style.background = '#d4edda';
                    statusCountEl.style.color = '#28a745';
                } else if (count === total) {
                    statusCountEl.textContent = 'All';
                    statusCountEl.style.background = '#d4edda';
                    statusCountEl.style.color = '#28a745';
                } else {
                    statusCountEl.textContent = `${count} of ${total}`;
                    statusCountEl.style.background = '#e7f3ff';
                    statusCountEl.style.color = '#007bff';
                }
            }
            
            if (shopTypeCountEl) {
                const count = shopTypeSelected.length;
                const total = document.querySelectorAll('.shop-type-filter-checkbox').length;
                if (count === 0) {
                    shopTypeCountEl.textContent = 'All';
                    shopTypeCountEl.style.background = '#d4edda';
                    shopTypeCountEl.style.color = '#28a745';
                } else if (count === total) {
                    shopTypeCountEl.textContent = 'All';
                    shopTypeCountEl.style.background = '#d4edda';
                    shopTypeCountEl.style.color = '#28a745';
                } else {
                    shopTypeCountEl.textContent = `${count} of ${total}`;
                    shopTypeCountEl.style.background = '#d4edda';
                    shopTypeCountEl.style.color = '#28a745';
                }
            }
            
            if (statusSummaryEl) {
                if (statusSelected.length === 0) {
                    statusSummaryEl.textContent = 'âœ“ Showing all statuses (no filter applied)';
                    statusSummaryEl.style.color = '#28a745';
                } else if (statusSelected.length === 1) {
                    statusSummaryEl.textContent = `Filtering by: ${statusSelected[0]}`;
                    statusSummaryEl.style.color = '#6c757d';
                } else {
                    statusSummaryEl.textContent = `Filtering by: ${statusSelected.join(', ')}`;
                    statusSummaryEl.style.color = '#6c757d';
                }
            }
            
            if (shopTypeSummaryEl) {
                if (shopTypeSelected.length === 0) {
                    shopTypeSummaryEl.textContent = 'âœ“ Showing all shop types (no filter applied)';
                    shopTypeSummaryEl.style.color = '#28a745';
                } else if (shopTypeSelected.length === 1) {
                    shopTypeSummaryEl.textContent = `Filtering by: ${shopTypeSelected[0]}`;
                    shopTypeSummaryEl.style.color = '#6c757d';
                } else {
                    shopTypeSummaryEl.textContent = `Filtering by: ${shopTypeSelected.join(', ')}`;
                    shopTypeSummaryEl.style.color = '#6c757d';
                }
            }
        }
        
        // Add event listeners for normal view checkboxes
        document.querySelectorAll('.status-filter-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                // Sync to expanded view if map is expanded
                if (isMapExpanded) {
                    syncCheckboxes('.status-filter-checkbox', '.expanded-status-filter-checkbox');
                }
                
                // Save filter states
                saveFilterStates();
                
                // Update counts and summaries
                updateFilterCounts();
                
                // Update status description (show first selected or "Multiple")
                const selected = getSelectedStatusFilters();
                if (selected.length === 1) {
                    updateStatusDescription(selected[0]);
                } else if (selected.length > 1) {
                    updateStatusDescription('Multiple');
                } else {
                    updateStatusDescription('');
                }
            
            // Only auto-search if we have valid coordinates
            if (currentLat && currentLng) {
                searchStores();
            }
            });
        });
        
        document.querySelectorAll('.shop-type-filter-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                // Sync to expanded view if map is expanded
                if (isMapExpanded) {
                    syncCheckboxes('.shop-type-filter-checkbox', '.expanded-shop-type-filter-checkbox');
                }
                
                // Save filter states
                saveFilterStates();
                
                // Update counts and summaries
                updateFilterCounts();
                
                // Only auto-search if we have valid coordinates
                if (currentLat && currentLng) {
                    searchStores();
                }
            });
        });
        
        // Select All / Clear All buttons
        document.getElementById('selectAllStatuses')?.addEventListener('click', function() {
            document.querySelectorAll('.status-filter-checkbox').forEach(cb => cb.checked = true);
            document.querySelectorAll('.status-filter-checkbox').forEach(cb => cb.dispatchEvent(new Event('change')));
            saveFilterStates();
            updateFilterCounts();
        });
        
        document.getElementById('clearAllStatuses')?.addEventListener('click', function() {
            document.querySelectorAll('.status-filter-checkbox').forEach(cb => cb.checked = false);
            document.querySelectorAll('.status-filter-checkbox').forEach(cb => cb.dispatchEvent(new Event('change')));
            saveFilterStates();
            updateFilterCounts();
        });
        
        document.getElementById('selectAllShopTypes')?.addEventListener('click', function() {
            document.querySelectorAll('.shop-type-filter-checkbox').forEach(cb => cb.checked = true);
            document.querySelectorAll('.shop-type-filter-checkbox').forEach(cb => cb.dispatchEvent(new Event('change')));
            saveFilterStates();
            updateFilterCounts();
        });
        
        document.getElementById('clearAllShopTypes')?.addEventListener('click', function() {
            document.querySelectorAll('.shop-type-filter-checkbox').forEach(cb => cb.checked = false);
            document.querySelectorAll('.shop-type-filter-checkbox').forEach(cb => cb.dispatchEvent(new Event('change')));
            saveFilterStates();
            updateFilterCounts();
        });
        
        // Update URL with current filter and location state
        function updateURLState(replaceState = false) {
            try {
                const params = new URLSearchParams();
                
                // Add location - always use the original point of origin (currentLat/currentLng)
                // Never use map center, as that would overwrite the original location
                if (currentLat && currentLng) {
                    params.set('lat', currentLat.toString());
                    params.set('lng', currentLng.toString());
                }
                
                // Add status filters
                const statusFilters = getSelectedStatusFilters();
                if (statusFilters.length > 0) {
                    statusFilters.forEach(status => {
                        params.append('status', status);
                    });
                }
                
                // Add shop type filters
                const shopTypeFilters = getSelectedShopTypeFilters();
                if (shopTypeFilters.length > 0) {
                    shopTypeFilters.forEach(shopType => {
                        params.append('shop_type', shopType);
                    });
                }
                
                // Add map expanded state
                if (isMapExpanded) {
                    params.set('map_expanded', 'true');
                    
                    // Add map bounds if in expanded view
                    if (map) {
                        const bounds = map.getBounds();
                        const ne = bounds.getNorthEast();
                        const sw = bounds.getSouthWest();
                        params.set('ne_lat', ne.lat.toString());
                        params.set('ne_lng', ne.lng.toString());
                        params.set('sw_lat', sw.lat.toString());
                        params.set('sw_lng', sw.lng.toString());
                    }
                    
                    // Add panel collapsed state
                    const header = document.getElementById('expandedMapHeader');
                    if (header && header.classList.contains('collapsed')) {
                        params.set('panel_collapsed', 'true');
                    } else {
                        params.delete('panel_collapsed');
                    }
                } else {
                    // Remove expanded state from URL if not expanded
                    params.delete('map_expanded');
                    params.delete('ne_lat');
                    params.delete('ne_lng');
                    params.delete('sw_lat');
                    params.delete('sw_lng');
                    params.delete('panel_collapsed');
                }
                
                // Update URL without page reload
                const newURL = window.location.pathname + (params.toString() ? '?' + params.toString() : '');
                if (replaceState) {
                    window.history.replaceState({}, '', newURL);
                } else {
                    window.history.pushState({}, '', newURL);
                }
            } catch (e) {
                console.warn('Failed to update URL state:', e);
            }
        }
        
        // Load filter and location state from URL
        function loadStateFromURL() {
            try {
                const params = new URLSearchParams(window.location.search);
                let hasURLParams = false;
                
                // Load location
                const urlLat = params.get('lat');
                const urlLng = params.get('lng');
                if (urlLat && urlLng) {
                    const lat = parseFloat(urlLat);
                    const lng = parseFloat(urlLng);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        currentLat = lat;
                        currentLng = lng;
                        currentLocationLabel = 'Your Location (Start)';
                        hasURLParams = true;
                        
                        // Update map if initialized (but don't change view if restoring from URL with bounds)
                        if (map) {
                            // Only update map view if not restoring from URL with bounds
                            // The restoreStateFromURL function will handle setting the bounds
                            const params = new URLSearchParams(window.location.search);
                            const urlMapExpanded = params.get('map_expanded');
                            const hasBounds = params.get('ne_lat') && params.get('ne_lng') && params.get('sw_lat') && params.get('sw_lng');
                            
                            if (urlMapExpanded === 'true' && hasBounds) {
                                // Don't update map view here - let restoreStateFromURL handle it
                                // Just update the currentLat/currentLng values
                                currentLat = lat;
                                currentLng = lng;
                            } else {
                                updateMap(lat, lng, []);
                            }
                        }
                    }
                }
                
                // Load status filters - wait for checkboxes to exist
                const statusCheckboxes = document.querySelectorAll('.status-filter-checkbox');
                if (statusCheckboxes.length > 0) {
                    const urlStatusFilters = params.getAll('status');
                    if (urlStatusFilters.length > 0) {
                        hasURLParams = true;
                        // Set checkboxes based on URL params
                        statusCheckboxes.forEach(cb => {
                            cb.checked = urlStatusFilters.includes(cb.value);
                        });
                        document.querySelectorAll('.expanded-status-filter-checkbox').forEach(cb => {
                            cb.checked = urlStatusFilters.includes(cb.value);
                        });
                    } else {
                        // Default: select all only if no URL params at all
                        if (!hasURLParams) {
                            statusCheckboxes.forEach(cb => cb.checked = true);
                            document.querySelectorAll('.expanded-status-filter-checkbox').forEach(cb => cb.checked = true);
                        }
                    }
                }
                
                // Load shop type filters - wait for checkboxes to exist
                const shopTypeCheckboxes = document.querySelectorAll('.shop-type-filter-checkbox');
                if (shopTypeCheckboxes.length > 0) {
                    const urlShopTypeFilters = params.getAll('shop_type');
                    if (urlShopTypeFilters.length > 0) {
                        hasURLParams = true;
                        shopTypeCheckboxes.forEach(cb => {
                            cb.checked = urlShopTypeFilters.includes(cb.value);
                        });
                        document.querySelectorAll('.expanded-shop-type-filter-checkbox').forEach(cb => {
                            cb.checked = urlShopTypeFilters.includes(cb.value);
                        });
                    } else {
                        // Default: select all only if no URL params at all
                        if (!hasURLParams) {
                            shopTypeCheckboxes.forEach(cb => cb.checked = true);
                            document.querySelectorAll('.expanded-shop-type-filter-checkbox').forEach(cb => cb.checked = true);
                        }
                    }
                }
                
                // If we loaded location from URL, trigger search if filters are present
                // But skip if map is expanded - loadStoresForBounds will handle it with higher limit
                if (hasURLParams && currentLat && currentLng) {
                    const urlMapExpanded = params.get('map_expanded');
                    const urlStatusFilters = params.getAll('status');
                    const urlShopTypeFilters = params.getAll('shop_type');
                    // Auto-search if we have location and at least one filter, but only if map is NOT expanded
                    // If map is expanded, loadStoresForBounds will be called during restoration with limit 200
                    if ((urlStatusFilters.length > 0 || urlShopTypeFilters.length > 0) && urlMapExpanded !== 'true') {
                        // Delay search to ensure filters are applied
                        setTimeout(() => {
                            if (currentLat && currentLng) {
                                searchStores();
                            }
                        }, 300);
                    }
                }
                
                return hasURLParams;
            } catch (e) {
                console.warn('Failed to load state from URL:', e);
                return false;
            }
        }
        
        // Save filter states to localStorage (as backup)
        function saveFilterStates() {
            try {
                const statusFilters = getSelectedStatusFilters();
                const shopTypeFilters = getSelectedShopTypeFilters();
                
                localStorage.setItem('storeFilters_status', JSON.stringify(statusFilters));
                localStorage.setItem('storeFilters_shopType', JSON.stringify(shopTypeFilters));
                
                // Also update URL
                updateURLState(true); // Use replaceState to avoid cluttering history
            } catch (e) {
                console.warn('Failed to save filter states:', e);
            }
        }
        
        // Restore map expanded state from URL (called after map is initialized)
        function restoreStateFromURL() {
            // Don't restore if already expanded or if restoration is in progress
            if (isMapExpanded || isRestoringFromURL) return;
            
            // Ensure map exists and is initialized
            if (!map) {
                // Try to initialize map if it doesn't exist
                initMap();
                // If still no map, wait a bit and try again
                if (!map) {
                    setTimeout(() => restoreStateFromURL(), 200);
                    return;
                }
            }
            
            // If map isn't initialized yet, wait
            if (!mapInitialized) {
                setTimeout(() => restoreStateFromURL(), 100);
                return;
            }
            
            try {
                const params = new URLSearchParams(window.location.search);
                const urlMapExpanded = params.get('map_expanded');
                
                // Get lat/lng from URL if not already set
                if (!currentLat || !currentLng) {
                    const urlLat = params.get('lat');
                    const urlLng = params.get('lng');
                    if (urlLat && urlLng) {
                        const lat = parseFloat(urlLat);
                        const lng = parseFloat(urlLng);
                        if (!isNaN(lat) && !isNaN(lng)) {
                            currentLat = lat;
                            currentLng = lng;
                            currentLocationLabel = 'Your Location (Start)';
                        }
                    }
                }
                
                if (urlMapExpanded === 'true' && currentLat && currentLng) {
                    // Ensure map element exists before expanding
                    const mapEl = document.getElementById('map');
                    if (!mapEl) {
                        // Wait for DOM to be ready
                        setTimeout(() => restoreStateFromURL(), 100);
                        return;
                    }
                    
                    // Ensure map is fully initialized before expanding
                    if (!map || !mapInitialized) {
                        // Wait a bit more for map to be ready
                        setTimeout(() => restoreStateFromURL(), 200);
                        return;
                    }
                    
                    // All checks passed, set flag and expand
                    isRestoringFromURL = true;
                    
                    // Expand map without URL update (to avoid circular updates)
                    // skipURLUpdate=true allows expandMap to proceed even when isRestoringFromURL is true
                    expandMap(true);
                    
                    // Verify expansion succeeded, retry if needed with longer delay
                    setTimeout(() => {
                        if (!isMapExpanded && map && mapEl) {
                            // Expansion might have failed, reset flag and try again
                            console.log('Retrying map expansion - first attempt failed');
                            const wasRestoring = isRestoringFromURL;
                            isRestoringFromURL = false; // Temporarily reset to allow retry
                            expandMap(true);
                            isRestoringFromURL = wasRestoring; // Restore flag
                            
                            // If still not expanded after retry, try one more time with even longer delay
                            setTimeout(() => {
                                if (!isMapExpanded && map && mapEl) {
                                    console.log('Second retry for map expansion...');
                                    isRestoringFromURL = false;
                                    expandMap(true);
                                    isRestoringFromURL = true;
                                }
                            }, 500);
                        }
                    }, 300);
                    
                    // If bounds are in URL, restore them after a delay to ensure map is ready
                    setTimeout(() => {
                        if (!map || !isMapExpanded) {
                            isRestoringFromURL = false;
                            return;
                        }
                        
                        const urlNeLat = params.get('ne_lat');
                        const urlNeLng = params.get('ne_lng');
                        const urlSwLat = params.get('sw_lat');
                        const urlSwLng = params.get('sw_lng');
                        
                        if (urlNeLat && urlNeLng && urlSwLat && urlSwLng) {
                            const neLat = parseFloat(urlNeLat);
                            const neLng = parseFloat(urlNeLng);
                            const swLat = parseFloat(urlSwLat);
                            const swLng = parseFloat(urlSwLng);
                            
                            if (!isNaN(neLat) && !isNaN(neLng) && !isNaN(swLat) && !isNaN(swLng)) {
                                // Create bounds and set map view
                                const ne = L.latLng(neLat, neLng);
                                const sw = L.latLng(swLat, swLng);
                                const bounds = L.latLngBounds(sw, ne);
                                
                                // Wait for map to be fully resized before setting bounds
                                map.invalidateSize();
                                
                                setTimeout(() => {
                                    if (map && isMapExpanded) {
                                        // Temporarily remove moveend and zoomend listeners to prevent bounds changes during restoration
                                        map.off('moveend', handleMapBoundsChange);
                                        map.off('zoomend', handleMapBoundsChange);
                                        
                                        // Set bounds strictly - use fitBounds with padding 0 to match exact bounds
                                        map.fitBounds(bounds, { padding: [0, 0] });
                                        
                                        // Invalidate map size to ensure bounds are properly calculated
                                        map.invalidateSize();
                                        
                                        // Wait for map moveend event to ensure bounds are fully applied
                                        const onBoundsSet = () => {
                                            if (map && isMapExpanded) {
                                                // Remove this one-time listener
                                                map.off('moveend', onBoundsSet);
                                                
                                                // Ensure checkboxes are synced before loading stores
                                                syncCheckboxes('.status-filter-checkbox', '.expanded-status-filter-checkbox');
                                                syncCheckboxes('.shop-type-filter-checkbox', '.expanded-shop-type-filter-checkbox');
                                                
                                                // Load stores without triggering URL updates
                                                loadStoresForBounds();
                                            }
                                        };
                                        
                                        // Listen for moveend to know when bounds are set
                                        map.once('moveend', onBoundsSet);
                                        
                                        // Fallback timeout in case moveend doesn't fire
                                        setTimeout(() => {
                                            if (map && isMapExpanded) {
                                                map.off('moveend', onBoundsSet);
                                                // Ensure checkboxes are synced before loading stores
                                                syncCheckboxes('.status-filter-checkbox', '.expanded-status-filter-checkbox');
                                                syncCheckboxes('.shop-type-filter-checkbox', '.expanded-shop-type-filter-checkbox');
                                                loadStoresForBounds();
                                            }
                                        }, 1000);
                                        
                                        // Re-enable moveend and zoomend listeners after stores are loaded
                                        setTimeout(() => {
                                            if (map && isMapExpanded) {
                                                map.on('moveend', handleMapBoundsChange);
                                                map.on('zoomend', handleMapBoundsChange);
                                                
                                                // Ensure user marker is placed at original point of origin (after everything is loaded)
                                                if (currentLat && currentLng) {
                                                    // Remove existing user marker if any
                                                    if (userMarker) {
                                                        map.removeLayer(userMarker);
                                                    }
                                                    // Place user marker at original lat/lng from URL
                                                    userMarker = L.marker([currentLat, currentLng], {
                                                        icon: L.icon({
                                                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                                                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                                                            iconSize: [25, 41],
                                                            iconAnchor: [12, 41],
                                                            popupAnchor: [1, -34],
                                                            shadowSize: [41, 41]
                                                        })
                                                    }).addTo(map)
                                                    .bindPopup(`<strong>${currentLocationLabel}</strong><br>` + currentLat.toFixed(6) + ', ' + currentLng.toFixed(6));
                                                }
                                                
                                                // Restore panel collapsed state
                                                const urlPanelCollapsed = params.get('panel_collapsed');
                                                if (urlPanelCollapsed === 'true') {
                                                    const header = document.getElementById('expandedMapHeader');
                                                    const mapEl = document.getElementById('map');
                                                    const toggleIcon = document.getElementById('togglePanelIcon');
                                                    if (header && mapEl) {
                                                        header.classList.add('collapsed');
                                                        mapEl.classList.add('panel-hidden');
                                                        if (toggleIcon) {
                                                            toggleIcon.textContent = 'â–²';
                                                        }
                                                        // Invalidate map size after collapsing panel
                                                        setTimeout(() => {
                                                            if (map) {
                                                                map.invalidateSize();
                                                            }
                                                        }, 100);
                                                    }
                                                }
                                                
                                                isRestoringFromURL = false;
                                            }
                                        }, 1500);
                                    } else {
                                        isRestoringFromURL = false;
                                    }
                                }, 200);
                            } else {
                                // No bounds in URL, but still restore panel state and user marker if present
                                setTimeout(() => {
                                    if (map && isMapExpanded) {
                                        // Ensure user marker is placed at original point of origin
                                        if (currentLat && currentLng) {
                                            if (userMarker) {
                                                map.removeLayer(userMarker);
                                            }
                                            userMarker = L.marker([currentLat, currentLng], {
                                                icon: L.icon({
                                                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                                                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                                                    iconSize: [25, 41],
                                                    iconAnchor: [12, 41],
                                                    popupAnchor: [1, -34],
                                                    shadowSize: [41, 41]
                                                })
                                            }).addTo(map)
                                            .bindPopup(`<strong>${currentLocationLabel}</strong><br>` + currentLat.toFixed(6) + ', ' + currentLng.toFixed(6));
                                        }
                                        
                                        // Ensure checkboxes are synced and load stores for current bounds
                                        syncCheckboxes('.status-filter-checkbox', '.expanded-status-filter-checkbox');
                                        syncCheckboxes('.shop-type-filter-checkbox', '.expanded-shop-type-filter-checkbox');
                                        
                                        // Load stores for current map bounds
                                        setTimeout(() => {
                                            if (map && isMapExpanded) {
                                                loadStoresForBounds();
                                            }
                                        }, 200);
                                        
                                        const urlPanelCollapsed = params.get('panel_collapsed');
                                        if (urlPanelCollapsed === 'true') {
                                            const header = document.getElementById('expandedMapHeader');
                                            const mapEl = document.getElementById('map');
                                            const toggleIcon = document.getElementById('togglePanelIcon');
                                            if (header && mapEl) {
                                                header.classList.add('collapsed');
                                                mapEl.classList.add('panel-hidden');
                                                if (toggleIcon) {
                                                    toggleIcon.textContent = 'â–²';
                                                }
                                                setTimeout(() => {
                                                    if (map) {
                                                        map.invalidateSize();
                                                    }
                                                }, 100);
                                            }
                                        }
                                    }
                                    isRestoringFromURL = false;
                                }, 200);
                            }
                        } else {
                            // No bounds in URL, but still restore panel state and user marker if present
                            setTimeout(() => {
                                if (map && isMapExpanded) {
                                    // Ensure user marker is placed at original point of origin
                                    if (currentLat && currentLng) {
                                        if (userMarker) {
                                            map.removeLayer(userMarker);
                                        }
                                        userMarker = L.marker([currentLat, currentLng], {
                                            icon: L.icon({
                                                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                                                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                                                iconSize: [25, 41],
                                                iconAnchor: [12, 41],
                                                popupAnchor: [1, -34],
                                                shadowSize: [41, 41]
                                            })
                                        }).addTo(map)
                                        .bindPopup(`<strong>${currentLocationLabel}</strong><br>` + currentLat.toFixed(6) + ', ' + currentLng.toFixed(6));
                                    }
                                    
                                    // Ensure checkboxes are synced and load stores for current bounds
                                    syncCheckboxes('.status-filter-checkbox', '.expanded-status-filter-checkbox');
                                    syncCheckboxes('.shop-type-filter-checkbox', '.expanded-shop-type-filter-checkbox');
                                    
                                    // Load stores for current map bounds
                                    setTimeout(() => {
                                        if (map && isMapExpanded) {
                                            loadStoresForBounds();
                                        }
                                    }, 200);
                                    
                                    const urlPanelCollapsed = params.get('panel_collapsed');
                                    if (urlPanelCollapsed === 'true') {
                                        const header = document.getElementById('expandedMapHeader');
                                        const mapEl = document.getElementById('map');
                                        const toggleIcon = document.getElementById('togglePanelIcon');
                                        if (header && mapEl) {
                                            header.classList.add('collapsed');
                                            mapEl.classList.add('panel-hidden');
                                            if (toggleIcon) {
                                                toggleIcon.textContent = 'â–²';
                                            }
                                            setTimeout(() => {
                                                if (map) {
                                                    map.invalidateSize();
                                                }
                                            }, 100);
                                        }
                                    }
                                }
                                isRestoringFromURL = false;
                            }, 200);
                        }
                    }, 400);
                } else if (currentLat && currentLng && map) {
                    // Map is not expanded but we have lat/lng from URL - ensure user marker is placed at original point of origin
                    if (userMarker) {
                        map.removeLayer(userMarker);
                    }
                    userMarker = L.marker([currentLat, currentLng], {
                        icon: L.icon({
                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                            iconSize: [25, 41],
                            iconAnchor: [12, 41],
                            popupAnchor: [1, -34],
                            shadowSize: [41, 41]
                        })
                    }).addTo(map)
                    .bindPopup(`<strong>${currentLocationLabel}</strong><br>` + currentLat.toFixed(6) + ', ' + currentLng.toFixed(6));
                }
            } catch (e) {
                console.warn('Failed to restore map state from URL:', e);
                isRestoringFromURL = false;
            }
        }
        
        // Load filter states (from URL first, then localStorage as fallback)
        function loadFilterStates() {
            // Try loading from URL first
            const loadedFromURL = loadStateFromURL();
            
            // If URL didn't have state, try localStorage
            if (!loadedFromURL) {
                try {
                    const savedStatus = localStorage.getItem('storeFilters_status');
                    const savedShopType = localStorage.getItem('storeFilters_shopType');
                    
                    // If we have saved states, restore them; otherwise, select all by default
                    if (savedStatus) {
                        const statusFilters = JSON.parse(savedStatus);
                        document.querySelectorAll('.status-filter-checkbox').forEach(cb => {
                            cb.checked = statusFilters.includes(cb.value);
                        });
                        document.querySelectorAll('.expanded-status-filter-checkbox').forEach(cb => {
                            cb.checked = statusFilters.includes(cb.value);
                        });
                    } else {
                        // Default: select all
                        document.querySelectorAll('.status-filter-checkbox').forEach(cb => cb.checked = true);
                        document.querySelectorAll('.expanded-status-filter-checkbox').forEach(cb => cb.checked = true);
                    }
                    
                    if (savedShopType) {
                        const shopTypeFilters = JSON.parse(savedShopType);
                        document.querySelectorAll('.shop-type-filter-checkbox').forEach(cb => {
                            cb.checked = shopTypeFilters.includes(cb.value);
                        });
                        document.querySelectorAll('.expanded-shop-type-filter-checkbox').forEach(cb => {
                            cb.checked = shopTypeFilters.includes(cb.value);
                        });
                    } else {
                        // Default: select all
                        document.querySelectorAll('.shop-type-filter-checkbox').forEach(cb => cb.checked = true);
                        document.querySelectorAll('.expanded-shop-type-filter-checkbox').forEach(cb => cb.checked = true);
                    }
                } catch (e) {
                    console.warn('Failed to load filter states:', e);
                    // Fallback: select all
                    document.querySelectorAll('.status-filter-checkbox').forEach(cb => cb.checked = true);
                    document.querySelectorAll('.shop-type-filter-checkbox').forEach(cb => cb.checked = true);
                    document.querySelectorAll('.expanded-status-filter-checkbox').forEach(cb => cb.checked = true);
                    document.querySelectorAll('.expanded-shop-type-filter-checkbox').forEach(cb => cb.checked = true);
                }
            }
        }
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            // Prevent race conditions by checking if restoration is in progress
            if (isRestoringFromURL) return;
            
            // Reload state from URL when user navigates back/forward
            loadStateFromURL();
            updateFilterCounts();
            
            // Restore map state if needed
            if (mapInitialized) {
                restoreStateFromURL();
            }
            
            // If location was in URL, trigger search if we have coordinates
            if (currentLat && currentLng) {
                const params = new URLSearchParams(window.location.search);
                // Only auto-search if filters changed, not just location
                if (params.getAll('status').length > 0 || params.getAll('shop_type').length > 0) {
                    // Delay search to avoid race conditions
                    setTimeout(() => {
                        if (!isRestoringFromURL) {
                            searchStores();
                        }
                    }, 300);
                }
            }
        });
        
        // Initialize filter counts on page load
        // Load saved filter states or select all by default
        // Use DOMContentLoaded or delay to ensure checkboxes exist
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                loadFilterStates();
                updateFilterCounts();
            });
        } else {
            // DOM already loaded, but wait a bit for dynamic content
            setTimeout(() => {
                loadFilterStates();
                updateFilterCounts();
            }, 100);
        }

        // Note: Status description is initialized when storesContent is shown (after signature verification)

        // Handle form submission
        document.getElementById('searchForm').addEventListener('submit', function(e) {
            e.preventDefault();
            searchStores();
        });

        // Helper functions to get selected values from checkboxes
        function getSelectedStatusFilters() {
            const checkboxes = document.querySelectorAll('.status-filter-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }
        
        function getSelectedShopTypeFilters() {
            const checkboxes = document.querySelectorAll('.shop-type-filter-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }
        
        function getSelectedExpandedStatusFilters() {
            const checkboxes = document.querySelectorAll('.expanded-status-filter-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }
        
        function getSelectedExpandedShopTypeFilters() {
            const checkboxes = document.querySelectorAll('.expanded-shop-type-filter-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }
        
        // Sync checkbox states between normal and expanded views
        function syncCheckboxes(sourceClass, targetClass) {
            const sourceCheckboxes = document.querySelectorAll(sourceClass);
            const targetCheckboxes = document.querySelectorAll(targetClass);
            sourceCheckboxes.forEach((source, index) => {
                if (targetCheckboxes[index]) {
                    targetCheckboxes[index].checked = source.checked;
                }
            });
        }

        function searchStores() {
            const lat = currentLat;
            const lng = currentLng;
            // Get selected values from checkboxes (use expanded if in expanded view, otherwise normal)
            const statusFilters = isMapExpanded ? getSelectedExpandedStatusFilters() : getSelectedStatusFilters();
            const shopTypeFilters = isMapExpanded ? getSelectedExpandedShopTypeFilters() : getSelectedShopTypeFilters();

            if (!lat || !lng || isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) {
                const statusMessage = document.getElementById('statusMessage');
                statusMessage.innerHTML = '<div class="error">Location not detected. Please use "Use Current Location" button.</div>';
                return;
            }

            // Show loading state
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.innerHTML = '<div class="loading"><div class="spinner"></div>Searching for nearby stores...</div>';
            document.getElementById('storesContainer').innerHTML = '';
            document.getElementById('searchBtn').disabled = true;

            // Build URL with parameters
            const resultLimit = pendingStoreDeepLink && pendingStoreDeepLink.storeKey ? '50' : '10';
            const params = new URLSearchParams({
                lat: lat.toString(),
                lng: lng.toString(),
                limit: resultLimit
            });
            
            // Include status filters as array (multiple values)
            if (statusFilters.length > 0) {
                statusFilters.forEach(status => {
                    params.append('status', status);
                });
            } else {
                // If no status selected, send empty to show all
                params.append('status', '');
            }
            
            // Include shop type filters as array (multiple values)
            if (shopTypeFilters.length > 0) {
                shopTypeFilters.forEach(shopType => {
                    params.append('shop_type', shopType);
                });
            } else {
                // If no shop type selected, send empty to show all
                params.append('shop_type', '');
            }

            // Fetch stores
            fetch(`${API_URL}?${params.toString()}`)
                .then(response => response.json())
                .then(data => {
                    document.getElementById('searchBtn').disabled = false;
                    
                    if (data.success) {
                        // Update map with stores (this will apply TSP ordering)
                        updateMap(lat, lng, data.stores);
                        
                        // Display stores (using the TSP-ordered stores from updateMap)
                        const statusText = statusFilters.length > 0 ? ` (Status: ${statusFilters.join(', ')})` : ' (All Statuses)';
                        displayStores(data.stores, statusFilters.length > 0 ? statusFilters.join(', ') : '');
                        const shopTypeText = shopTypeFilters.length > 0 ? ` (Shop Type: ${shopTypeFilters.join(', ')})` : '';
                        const routeInfo = window.totalRouteDistance ? ` â€¢ Route: ${window.totalRouteDistance.toFixed(1)} miles` : '';
                        statusMessage.innerHTML = 
                            `<div class="status">Found ${data.count} store${data.count !== 1 ? 's' : ''} nearby${statusText}${shopTypeText}${routeInfo}</div>`;
                    } else {
                        statusMessage.innerHTML = 
                            `<div class="error">Error: ${data.error || data.message || 'Unknown error'}</div>`;
                    }
                })
                .catch(error => {
                    document.getElementById('searchBtn').disabled = false;
                    statusMessage.innerHTML = 
                        `<div class="error">Error fetching stores: ${error.message}</div>`;
                    console.error('Error:', error);
                });
        }

        function displayStores(stores, statusFilter) {
            const container = document.getElementById('storesContainer');
            
            if (stores.length === 0) {
                container.innerHTML = '<div class="status">No stores found matching your criteria.</div>';
                return;
            }

            // Use ordered stores from TSP if available, otherwise use original order
            const displayStores = window.orderedStoresData || stores;
            knownStoresByKey.clear();
            
            let html = '<div class="stores-list">';
            
            // Show total route distance if TSP was applied
            if (window.totalRouteDistance !== undefined && window.orderedStoresData) {
                html += `
                    <div style="background: #e7f3ff; border: 1px solid #007bff; border-radius: 5px; padding: 1rem; margin-bottom: 1rem; text-align: center;">
                        <strong>ðŸ—ºï¸ Optimized Route</strong><br>
                        <span style="font-size: 0.9rem;">Total route distance: <strong>${window.totalRouteDistance.toFixed(1)} miles</strong></span>
                    </div>
                `;
            }
            
            displayStores.forEach((store, index) => {
                const storeKey = createStoreKey(store);
                store.storeKey = storeKey;
                if (storeKey) {
                    knownStoresByKey.set(storeKey.toLowerCase(), {
                        store,
                        index
                    });
                }
                const priorityBadge = getPriorityBadge(store.priority);
                const statusBadge = getStatusBadge(store.status);
                const routeOrder = store.routeOrder || (index + 1);
                const latNumber = store.latitude !== undefined ? parseFloat(store.latitude) : NaN;
                const lngNumber = store.longitude !== undefined ? parseFloat(store.longitude) : NaN;
                const hasCoordinates = !Number.isNaN(latNumber) && !Number.isNaN(lngNumber);
                const coordinatesBadge = hasCoordinates
                    ? `<span class="store-coordinates" title="Coordinates captured for this shop">ðŸ“ ${latNumber.toFixed(4)}, ${lngNumber.toFixed(4)}</span>`
                    : '';
                
                html += `
                    <div class="store-card" id="store-card-${index}" onclick="toggleStoreDetails(${index}, event)" data-store-index="${index}" data-store-key="${storeKey}">
                        <div class="store-header">
                            <div class="store-name">Stop ${routeOrder}: ${escapeHtml(store.name)}</div>
                            <div class="store-distance">${store.distance} mi</div>
                        </div>
                        <div class="store-info">
                            ${escapeHtml(store.address)}${store.city ? ', ' + escapeHtml(store.city) : ''}${store.state ? ', ' + escapeHtml(store.state) : ''}
                        </div>
                        <div class="store-meta">
                            ${store.routeDistance ? `<span style="color: #007bff; font-weight: 600;">Route: ${store.routeDistance.toFixed(1)} mi from previous</span>` : ''}
                            ${priorityBadge}
                            ${statusBadge}
                            ${store.shop_type ? '<span>Type: ' + escapeHtml(store.shop_type) + '</span>' : ''}
                            ${coordinatesBadge}
                        </div>
                        ${store.follow_up_date || store.follow_up_event_link || store.contact_person ? `
                            <div class="store-followup">
                                ${store.follow_up_date ? 'ðŸ“… <strong>Follow-up:</strong> ' + escapeHtml(store.follow_up_date) : ''}
                                ${store.contact_person ? (store.follow_up_date ? '<br>' : '') + '<strong>Contact:</strong> ' + escapeHtml(store.contact_person) : ''}
                                ${store.follow_up_event_link ? '<br><a href="' + encodeURI(store.follow_up_event_link) + '" target="_blank" class="store-details-link" onclick="event.stopPropagation();">Open Calendar Event</a>' : ''}
                            </div>
                        ` : ''}
                        <div class="expand-indicator">Tap to view details</div>
                        <div class="store-details" id="details-${index}">
                            ${buildStoreDetails(store, index)}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
            
            // Store data globally for access
            window.storesData = displayStores;
            refreshSignatureDependentControls();
            focusStoreFromDeepLinkIfNeeded();
        }

        function getPriorityBadge(priority) {
            if (!priority) return '';
            const priorityLower = priority.toLowerCase();
            let badgeClass = 'badge-medium';
            if (priorityLower === 'high') badgeClass = 'badge-high';
            else if (priorityLower === 'low') badgeClass = 'badge-low';
            return `<span class="store-badge ${badgeClass}">${escapeHtml(priority)} Priority</span>`;
        }

        function getStatusBadge(status) {
            if (!status) return '';
            const statusLower = status.toLowerCase();
            let badgeClass = 'badge-research';
            if (statusLower === 'research') badgeClass = 'badge-research';
            else if (statusLower === 'shortlisted') badgeClass = 'badge-research';
            else if (statusLower === 'instagram followed') badgeClass = 'badge-instagram-followed';
            else if (statusLower === 'contacted') badgeClass = 'badge-contacted';
            else if (statusLower === 'manager follow-up' || statusLower === 'manager followup') badgeClass = 'badge-followup';
            else if (statusLower === 'meeting scheduled') badgeClass = 'badge-meeting-scheduled';
            else if (statusLower === 'followed up' || statusLower === 'followedup') badgeClass = 'badge-followedup';
            else if (statusLower === 'partnered') badgeClass = 'badge-partnered';
            else if (statusLower === 'on hold') badgeClass = 'badge-on-hold';
            else if (statusLower === 'rejected') badgeClass = 'badge-rejected';
            else if (statusLower === 'not appropriate') badgeClass = 'badge-rejected'; // Use rejected style for not appropriate
            return `<span class="store-badge ${badgeClass}">${escapeHtml(status)}</span>`;
        }

        function queueGoogleMapsCallback(callback) {
            if (!googleMapsState) return;
            if (googleMapsState.ready && !googleMapsState.error) {
                try {
                    callback();
                } catch (error) {
                    console.error('Google Maps callback execution error:', error);
                }
            } else {
                googleMapsState.callbacks.push(callback);
            }
        }

        function initPlaceAutocompleteElement() {
            const input = document.getElementById('newStoreName');
            if (!input || !googleMapsState || googleMapsState.error) {
                return;
            }
            if (placeAutocompleteElement) {
                return;
            }

            const host = document.getElementById('newStoreAutocompleteHost') || document.body;

            if (googleMapsState.placesLib && typeof googleMapsState.placesLib.PlaceAutocompleteElement === 'function') {
                try {
                    const { PlaceAutocompleteElement } = googleMapsState.placesLib;
                    const autocompleteElement = new PlaceAutocompleteElement();
                    autocompleteElement.inputElement = input;

                    if ('componentRestrictions' in autocompleteElement) {
                        autocompleteElement.componentRestrictions = { country: ['us'] };
                    } else {
                        autocompleteElement.setAttribute('component-restrictions', JSON.stringify({ country: ['us'] }));
                    }

                    const fields = [
                        'place_id',
                        'displayName',
                        'formattedAddress',
                        'addressComponents',
                        'location',
                        'formattedPhoneNumber',
                        'internationalPhoneNumber',
                        'websiteUri'
                    ];
                    if ('fields' in autocompleteElement) {
                        autocompleteElement.fields = fields;
                    } else {
                        autocompleteElement.setAttribute('fields', fields.join(','));
                    }

                    autocompleteElement.addEventListener('gmpx-placeautocomplete-select', handlePlaceSelection);
                    host.appendChild(autocompleteElement);
                    placeAutocompleteElement = autocompleteElement;
                    return;
                } catch (error) {
                    console.warn('Failed to initialize PlaceAutocompleteElement, falling back to legacy Autocomplete:', error);
                }
            }

            if (window.google && google.maps && google.maps.places && typeof google.maps.places.Autocomplete === 'function') {
                const legacyAutocomplete = new google.maps.places.Autocomplete(input, {
                    types: ['establishment'],
                    fields: [
                        'place_id',
                        'name',
                        'formatted_address',
                        'address_components',
                        'geometry',
                        'formatted_phone_number',
                        'international_phone_number',
                        'website'
                    ]
                });

                legacyAutocomplete.addListener('place_changed', () => {
                    const legacyPlace = legacyAutocomplete.getPlace();
                    if (legacyPlace) {
                        applyPlaceDetails(legacyPlace);
                    }
                });

                placeAutocompleteElement = legacyAutocomplete;
            }
        }

        function initAddressAutocompleteElement() {
            const input = document.getElementById('newStoreAddress');
            if (!input || !googleMapsState || googleMapsState.error) {
                return;
            }
            if (addressAutocompleteElement) {
                return;
            }

            const host = document.getElementById('newStoreAddressAutocompleteHost') || document.body;

            if (googleMapsState.placesLib && typeof googleMapsState.placesLib.PlaceAutocompleteElement === 'function') {
                try {
                    const { PlaceAutocompleteElement } = googleMapsState.placesLib;
                    const autocompleteElement = new PlaceAutocompleteElement();
                    autocompleteElement.inputElement = input;

                    if ('componentRestrictions' in autocompleteElement) {
                        autocompleteElement.componentRestrictions = { country: ['us'] };
                    } else {
                        autocompleteElement.setAttribute('component-restrictions', JSON.stringify({ country: ['us'] }));
                    }

                    // Use 'address' type instead of 'establishment' to search for addresses
                    if ('requestedResultTypes' in autocompleteElement) {
                        autocompleteElement.requestedResultTypes = ['address'];
                    } else {
                        autocompleteElement.setAttribute('requested-result-types', 'address');
                    }

                    const fields = [
                        'place_id',
                        'displayName',
                        'formattedAddress',
                        'addressComponents',
                        'location',
                        'formattedPhoneNumber',
                        'internationalPhoneNumber',
                        'websiteUri'
                    ];
                    if ('fields' in autocompleteElement) {
                        autocompleteElement.fields = fields;
                    } else {
                        autocompleteElement.setAttribute('fields', fields.join(','));
                    }

                    autocompleteElement.addEventListener('gmpx-placeautocomplete-select', handleAddressSelection);
                    host.appendChild(autocompleteElement);
                    addressAutocompleteElement = autocompleteElement;
                    return;
                } catch (error) {
                    console.warn('Failed to initialize Address PlaceAutocompleteElement, falling back to legacy Autocomplete:', error);
                }
            }

            if (window.google && google.maps && google.maps.places && typeof google.maps.places.Autocomplete === 'function') {
                const legacyAutocomplete = new google.maps.places.Autocomplete(input, {
                    types: ['address'], // Use 'address' type for address search
                    fields: [
                        'place_id',
                        'name',
                        'formatted_address',
                        'address_components',
                        'geometry',
                        'formatted_phone_number',
                        'international_phone_number',
                        'website'
                    ]
                });

                legacyAutocomplete.addListener('place_changed', () => {
                    const legacyPlace = legacyAutocomplete.getPlace();
                    if (legacyPlace) {
                        applyPlaceDetailsFromAddress(legacyPlace);
                    }
                });

                addressAutocompleteElement = legacyAutocomplete;
            }
        }

        async function handleAddressSelection(event) {
            if (!event || !googleMapsState || googleMapsState.error) {
                return;
            }

            const selectedPlace = event.detail && event.detail.place ? event.detail.place : null;
            if (!selectedPlace) {
                return;
            }

            let placeDetails = selectedPlace;

            try {
                if (typeof selectedPlace.fetchFields === 'function') {
                    placeDetails = await selectedPlace.fetchFields({
                        fields: [
                            'id',
                            'displayName',
                            'formattedAddress',
                            'addressComponents',
                            'location',
                            'formattedPhoneNumber',
                            'internationalPhoneNumber',
                            'websiteUri'
                        ]
                    });
                } else if (googleMapsState.placesLib && typeof googleMapsState.placesLib.Place === 'function' && (selectedPlace.placeId || selectedPlace.id)) {                                            
                    placeDetails = await googleMapsState.placesLib.Place.fetchFields({
                        placeId: selectedPlace.placeId || selectedPlace.id,
                        fields: [
                            'id',
                            'displayName',
                            'formattedAddress',
                            'addressComponents',
                            'location',
                            'formattedPhoneNumber',
                            'internationalPhoneNumber',
                            'websiteUri'
                        ]
                    });
                }
            } catch (error) {
                console.warn('Unable to fetch additional place fields:', error);
            }

            // When address is selected, populate all fields but don't overwrite shop name if it's already filled
            applyPlaceDetailsFromAddress(placeDetails);
        }

        function applyPlaceDetailsFromAddress(place) {
            if (!place) return;

            const nameInput = document.getElementById('newStoreName');
            const addressInput = document.getElementById('newStoreAddress');
            const cityInput = document.getElementById('newStoreCity');
            const stateSelect = document.getElementById('newStoreState');
            const phoneInput = document.getElementById('newStorePhone');
            const emailInput = document.getElementById('newStoreEmail');
            const websiteInput = document.getElementById('newStoreWebsite');
            const latInput = document.getElementById('newStoreLat');
            const lngInput = document.getElementById('newStoreLng');
            const locationStatusEl = document.getElementById('newStoreLocationStatus');

            // Only set shop name if it's empty
            const displayName = place.displayName && place.displayName.text ? place.displayName.text : place.name || '';
            if (displayName && nameInput && !nameInput.value.trim()) {
                nameInput.value = displayName;
            }

            const addressComponents = place.addressComponents || place.address_components || [];
            if (addressComponents.length) {
                const findComponent = (types) => {
                    return addressComponents.find(component => {
                        const componentTypes = component.types || [];
                        return types.some(type => componentTypes.includes(type));
                    });
                };

                const streetNumberComponent = findComponent(['street_number']);
                const routeComponent = findComponent(['route']);
                const localityComponent = findComponent(['locality', 'sublocality', 'postal_town']);
                const stateComponent = findComponent(['administrative_area_level_1']);

                const streetNumber = streetNumberComponent ? (streetNumberComponent.longText || streetNumberComponent.long_name || streetNumberComponent.shortText || streetNumberComponent.short_name || '') : '';                                                  
                const route = routeComponent ? (routeComponent.longText || routeComponent.long_name || routeComponent.shortText || routeComponent.short_name || '') : '';

                // Prefer parsed street address over formatted address to avoid redundant city/state in geocoding
                if (addressInput) {
                    const street = [streetNumber, route].filter(Boolean).join(' ').trim();
                    if (street) {
                        addressInput.value = street;
                    } else {
                        // Fallback to formatted address if we can't parse components
                        const formattedAddress = place.formattedAddress || place.formatted_address || '';
                        if (formattedAddress && !addressInput.value) {
                            addressInput.value = formattedAddress;
                        }
                    }
                }

                if (cityInput && localityComponent) {
                    const cityValue = localityComponent.longText || localityComponent.long_name || localityComponent.shortText || localityComponent.short_name || '';
                    if (cityValue) {
                        cityInput.value = cityValue;
                    }
                }

                if (stateSelect && stateComponent) {
                    const stateValue = stateComponent.shortText || stateComponent.short_name || stateComponent.longText || stateComponent.long_name || '';
                    const normalized = (stateValue || '').toUpperCase();
                    if (normalized && Array.from(stateSelect.options).some(opt => opt.value === normalized)) {
                        stateSelect.value = normalized;
                    }
                }
            }

            const phoneNumber = place.formattedPhoneNumber || place.formatted_phone_number || place.internationalPhoneNumber || place.international_phone_number;
            if (phoneInput && phoneNumber && !phoneInput.value) {
                phoneInput.value = phoneNumber;
            }

            // Note: Google Places API doesn't typically provide email addresses
            // This field is available for manual entry or if email is found during research
            // If you have a custom data source that provides email, you can populate it here
            const email = place.email || place.emailAddress || '';
            if (emailInput && email && !emailInput.value) {
                emailInput.value = email;
            }

            const website = place.websiteUri || place.website || '';
            if (websiteInput && website && !websiteInput.value) {
                websiteInput.value = website;
            }

            function setCoordinates(lat, lng) {
                if (latInput && lngInput && !isNaN(lat) && !isNaN(lng)) {
                    latInput.value = lat;
                    lngInput.value = lng;
                    updateNewStoreCoordinatesUI();
                    if (locationStatusEl) {
                        locationStatusEl.innerHTML = `<span style="color: #28a745;">ðŸ“ Coordinates set: ${lat.toFixed(4)}, ${lng.toFixed(4)}</span>`;
                    }
                    return true;
                }
                return false;
            }

            let coordinatesSet = false;

            // Helper to extract lat/lng from various formats
            function extractLatLng(obj) {
                if (!obj) return null;
                
                // Try function-based access (Google Maps LatLng object)
                if (typeof obj.lat === 'function' && typeof obj.lng === 'function') {
                    return { lat: obj.lat(), lng: obj.lng() };
                }
                
                // Try direct number access
                if (typeof obj.lat === 'number' && typeof obj.lng === 'number') {
                    return { lat: obj.lat, lng: obj.lng };
                }
                
                // Try nested latLng
                if (obj.latLng) {
                    const result = extractLatLng(obj.latLng);
                    if (result) return result;
                }
                
                return null;
            }

            // Try new Places API format first (place.location)
            if (place.location) {
                const coords = extractLatLng(place.location);
                if (coords) {
                    coordinatesSet = setCoordinates(coords.lat, coords.lng);
                }
            }
            
            // Try legacy format (place.geometry.location)
            if (!coordinatesSet && place.geometry) {
                if (place.geometry.location) {
                    const coords = extractLatLng(place.geometry.location);
                    if (coords) {
                        coordinatesSet = setCoordinates(coords.lat, coords.lng);
                    }
                }
                // Also try geometry.viewport center as fallback
                if (!coordinatesSet && place.geometry.viewport) {
                    const viewport = place.geometry.viewport;
                    if (viewport.getCenter && typeof viewport.getCenter === 'function') {
                        const center = viewport.getCenter();
                        const coords = extractLatLng(center);
                        if (coords) {
                            coordinatesSet = setCoordinates(coords.lat, coords.lng);
                        }
                    }
                }
            }

            // If coordinates weren't set, log for debugging
            if (!coordinatesSet) {
                console.warn('Could not extract coordinates from place object:', place);
                if (locationStatusEl) {
                    locationStatusEl.innerHTML = '<span style="color: #ffc107;">âš ï¸ Coordinates not available from address selection. Will attempt geocoding on submit.</span>';
                }
            }

            setNewStoreCardExpanded(true);
        }

        async function handlePlaceSelection(event) {
            if (!event || !googleMapsState || googleMapsState.error) {
                return;
            }

            const selectedPlace = event.detail && event.detail.place ? event.detail.place : null;
            if (!selectedPlace) {
                return;
            }

            let placeDetails = selectedPlace;

            try {
                if (typeof selectedPlace.fetchFields === 'function') {
                    placeDetails = await selectedPlace.fetchFields({
                        fields: [
                            'id',
                            'displayName',
                            'formattedAddress',
                            'addressComponents',
                            'location',
                            'formattedPhoneNumber',
                            'internationalPhoneNumber',
                            'websiteUri'
                        ]
                    });
                } else if (googleMapsState.placesLib && typeof googleMapsState.placesLib.Place === 'function' && (selectedPlace.placeId || selectedPlace.id)) {                                            
                    placeDetails = await googleMapsState.placesLib.Place.fetchFields({
                        placeId: selectedPlace.placeId || selectedPlace.id,
                        fields: [
                            'id',
                            'displayName',
                            'formattedAddress',
                            'addressComponents',
                            'location',
                            'formattedPhoneNumber',
                            'internationalPhoneNumber',
                            'websiteUri'
                        ]
                    });
                }
            } catch (error) {
                console.warn('Unable to fetch additional place fields:', error);
            }

            applyPlaceDetails(placeDetails);
        }

        function applyPlaceDetails(place) {
            if (!place) return;

            const nameInput = document.getElementById('newStoreName');
            const addressInput = document.getElementById('newStoreAddress');
            const cityInput = document.getElementById('newStoreCity');
            const stateSelect = document.getElementById('newStoreState');
            const phoneInput = document.getElementById('newStorePhone');
            const emailInput = document.getElementById('newStoreEmail');
            const websiteInput = document.getElementById('newStoreWebsite');
            const latInput = document.getElementById('newStoreLat');
            const lngInput = document.getElementById('newStoreLng');
            const locationStatusEl = document.getElementById('newStoreLocationStatus');

            const displayName = place.displayName && place.displayName.text ? place.displayName.text : place.name || '';
            if (displayName && nameInput) {
                nameInput.value = displayName;
            }

            const formattedAddress = place.formattedAddress || place.formatted_address || '';
            if (formattedAddress && addressInput) {
                addressInput.value = formattedAddress;
            }

            const addressComponents = place.addressComponents || place.address_components || [];
            if (addressComponents.length) {
                const findComponent = (types) => {
                    return addressComponents.find(component => {
                        const componentTypes = component.types || [];
                        return types.some(type => componentTypes.includes(type));
                    });
                };

                const streetNumberComponent = findComponent(['street_number']);
                const routeComponent = findComponent(['route']);
                const localityComponent = findComponent(['locality', 'sublocality', 'postal_town']);
                const stateComponent = findComponent(['administrative_area_level_1']);

                const streetNumber = streetNumberComponent ? (streetNumberComponent.longText || streetNumberComponent.long_name || streetNumberComponent.shortText || streetNumberComponent.short_name || '') : '';                                                  
                const route = routeComponent ? (routeComponent.longText || routeComponent.long_name || routeComponent.shortText || routeComponent.short_name || '') : '';

                if (addressInput) {
                    const street = [streetNumber, route].filter(Boolean).join(' ').trim();
                    if (street) {
                        addressInput.value = street;
                    }
                }

                if (cityInput && localityComponent) {
                    const cityValue = localityComponent.longText || localityComponent.long_name || localityComponent.shortText || localityComponent.short_name || '';
                    if (cityValue) {
                        cityInput.value = cityValue;
                    }
                }

                if (stateSelect && stateComponent) {
                    const stateValue = stateComponent.shortText || stateComponent.short_name || stateComponent.longText || stateComponent.long_name || '';
                    const normalized = (stateValue || '').toUpperCase();
                    if (normalized && Array.from(stateSelect.options).some(opt => opt.value === normalized)) {
                        stateSelect.value = normalized;
                    }
                }
            }

            const phoneNumber = place.formattedPhoneNumber || place.formatted_phone_number || place.internationalPhoneNumber || place.international_phone_number;
            if (phoneInput && phoneNumber) {
                phoneInput.value = phoneNumber;
            }

            // Note: Google Places API doesn't typically provide email addresses
            // This field is available for manual entry or if email is found during research
            const email = place.email || place.emailAddress || '';
            if (emailInput && email) {
                emailInput.value = email;
            }

            const website = place.websiteUri || place.website || '';
            if (websiteInput && website) {
                websiteInput.value = website;
            }

            function setCoordinates(lat, lng) {
                if (latInput) latInput.value = lat;
                if (lngInput) lngInput.value = lng;
                updateNewStoreCoordinatesUI();
                if (locationStatusEl) {
                    locationStatusEl.innerHTML = '';
                }
            }

            if (place.location) {
                if (typeof place.location.lat === 'function' && typeof place.location.lng === 'function') {
                    const lat = place.location.lat();
                    const lng = place.location.lng();
                    setCoordinates(lat, lng);
                } else if (typeof place.location.lat === 'number' && typeof place.location.lng === 'number') {
                    setCoordinates(place.location.lat, place.location.lng);
                } else if (place.location.latLng && typeof place.location.latLng.lat === 'number' && typeof place.location.latLng.lng === 'number') {
                    setCoordinates(place.location.latLng.lat, place.location.latLng.lng);
                }
            } else if (place.geometry && place.geometry.location) {
                const geom = place.geometry.location;
                if (typeof geom.lat === 'function' && typeof geom.lng === 'function') {
                    setCoordinates(geom.lat(), geom.lng());
                }
            }

            setNewStoreCardExpanded(true);
        }

        function initializeNewStoreForm() {
            if (newStoreFormInitialized) return;
            const card = document.getElementById('newStoreCard');
            const details = document.getElementById('newStoreDetails');
            const toggleBtn = document.getElementById('newStoreToggleBtn');
            const form = document.getElementById('newStoreForm');
            const locationBtn = document.getElementById('newStoreUseLocation');
            const addressInput = document.getElementById('newStoreAddress');
            const cityInput = document.getElementById('newStoreCity');
            const stateSelect = document.getElementById('newStoreState');

            if (!card || !details || !toggleBtn || !form) {
                return;
            }

            toggleBtn.addEventListener('click', () => {
                const isExpanded = card.classList.toggle('expanded');
                if (isExpanded) {
                    details.classList.add('expanded');
                    toggleBtn.textContent = 'Close Form';
                } else {
                    details.classList.remove('expanded');
                    toggleBtn.textContent = 'Open Form';
                }
            });

            if (locationBtn) {
                locationBtn.addEventListener('click', captureLocationForNewStore);
            }

            form.addEventListener('submit', handleNewStoreFormSubmit);
            const attemptGeocode = () => ensureNewStoreCoordinates(false);
            if (addressInput) {
                addressInput.addEventListener('blur', attemptGeocode);
                addressInput.addEventListener('change', attemptGeocode);
            }
            if (cityInput) {
                cityInput.addEventListener('blur', attemptGeocode);
                cityInput.addEventListener('change', attemptGeocode);
            }
            if (stateSelect) {
                stateSelect.addEventListener('change', attemptGeocode);
            }

            queueGoogleMapsCallback(initPlaceAutocompleteElement);
            queueGoogleMapsCallback(initAddressAutocompleteElement);
            refreshSignatureDependentControls();
            updateNewStoreCoordinatesUI();
            newStoreFormInitialized = true;
        }

        function setNewStoreCardExpanded(expanded) {
            const card = document.getElementById('newStoreCard');
            const details = document.getElementById('newStoreDetails');
            const toggleBtn = document.getElementById('newStoreToggleBtn');
            if (!card || !details || !toggleBtn) return;
            if (expanded) {
                card.classList.add('expanded');
                details.classList.add('expanded');
                toggleBtn.textContent = 'Close Form';
            } else {
                card.classList.remove('expanded');
                details.classList.remove('expanded');
                toggleBtn.textContent = 'Open Form';
            }
        }
        
        // Reset new store form
        function resetNewStoreForm() {
            const form = document.getElementById('newStoreForm');
            const submitBtn = document.getElementById('newStoreSubmitBtn');
            const messageEl = document.getElementById('newStoreStatusMessage');
            const locationStatusEl = document.getElementById('newStoreLocationStatus');
            
            // Clear all form fields explicitly
            const fields = [
                'newStoreName', 'newStoreAddress', 'newStoreCity', 'newStoreState',
                'newStorePhone', 'newStoreEmail', 'newStoreWebsite', 'newStoreInstagram',
                'newStoreShopType', 'newStoreStatus', 'newStoreRemarks',
                'newStoreLat', 'newStoreLng'
            ];
            
            fields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.value = '';
                }
            });
            
            // Reset form (this will also clear any autocomplete values)
            if (form) {
                form.reset();
            }
            
            // Reset button to original state
            const currentSubmitBtn = document.getElementById('newStoreSubmitBtn');
            if (currentSubmitBtn) {
                // Remove any existing click handlers by cloning the button
                const newBtn = currentSubmitBtn.cloneNode(true);
                currentSubmitBtn.parentNode.replaceChild(newBtn, currentSubmitBtn);
                // Set button back to original state
                newBtn.textContent = 'Save New Store';
                newBtn.type = 'submit';
                newBtn.disabled = false;
                // The form's submit handler will automatically work with the new button
            }
            
            // Clear messages
            if (messageEl) {
                messageEl.innerHTML = '';
            }
            if (locationStatusEl) {
                locationStatusEl.innerHTML = '';
            }
            
            // Update coordinates UI
            updateNewStoreCoordinatesUI();
        }

        async function captureLocationForNewStore(event) {
            if (event) event.preventDefault();
            if (interactionMode !== 'interactive') {
                showSignatureNoticeOnce('Connect your digital signature to capture locations.');
                return;
            }
            const statusEl = document.getElementById('newStoreLocationStatus');
            if (!navigator.geolocation) {
                if (statusEl) {
                    statusEl.innerHTML = '<span style="color: #dc3545;">Geolocation is not supported on this device.</span>';
                }
                return;
            }
            if (statusEl) {
                statusEl.innerHTML = '<span style="color: #007bff;">Detecting location...</span>';
            }
            
            // Set a timeout to prevent hanging
            const timeoutId = setTimeout(() => {
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color: #dc3545;">Location request timed out. Please try again.</span>`;
                }
            }, 15000); // 15 second timeout
            
            navigator.geolocation.getCurrentPosition(async (position) => {
                clearTimeout(timeoutId);
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const latInput = document.getElementById('newStoreLat');
                const lngInput = document.getElementById('newStoreLng');
                if (latInput) latInput.value = lat;
                if (lngInput) lngInput.value = lng;
                updateNewStoreCoordinatesUI();
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color: #28a745;">Location captured: ${lat.toFixed(4)}, ${lng.toFixed(4)}</span>`;
                }
                await populateNewStoreAddressFromCoords(lat, lng);
            }, (error) => {
                clearTimeout(timeoutId);
                let errorMsg = 'Unable to access location';
                if (error.code === 1) {
                    errorMsg = 'Permission denied. Please allow location access.';
                } else if (error.code === 2) {
                    errorMsg = 'Location unavailable. Please check your device settings.';
                } else if (error.code === 3) {
                    errorMsg = 'Location request timed out. Please try again.';
                } else {
                    errorMsg = error.message || 'Unable to access location';
                }
                if (statusEl) {
                    statusEl.innerHTML = `<span style="color: #dc3545;">${errorMsg}</span>`;
                }
            }, {
                enableHighAccuracy: true,
                timeout: 15000, // 15 second timeout
                maximumAge: 0 // Don't use cached location
            });
        }

        async function populateNewStoreAddressFromCoords(lat, lng) {
            const statusEl = document.getElementById('newStoreLocationStatus');
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lng}`, {
                    headers: {
                        'Accept': 'application/json',
                        'User-Agent': 'TrueSightDAO-DApp/1.0 (+https://truesightdao.github.io/dapp/)'
                    }
                });
                if (!response.ok) {
                    throw new Error('Reverse geocoding failed');
                }
                const data = await response.json();
                if (!data || !data.address) {
                    return;
                }
                const addr = data.address;
                const addressInput = document.getElementById('newStoreAddress');
                const cityInput = document.getElementById('newStoreCity');
                const stateInput = document.getElementById('newStoreState');

                const streetParts = [];
                if (addr.house_number) streetParts.push(addr.house_number);
                if (addr.road) streetParts.push(addr.road);
                const street = streetParts.join(' ').trim();
                if (addressInput && street && !addressInput.value) {
                    addressInput.value = street;
                }

                const cityCandidate = addr.city || addr.town || addr.village || addr.hamlet || addr.municipality;
                if (cityInput && cityCandidate && !cityInput.value) {
                    cityInput.value = cityCandidate;
                }

                if (stateInput) {
                    let stateValue = '';
                    if (addr.state_code) {
                        stateValue = addr.state_code.toUpperCase();
                    } else if (addr.state) {
                        const lookupKey = addr.state.toLowerCase();
                        stateValue = stateNameLookup[lookupKey] || '';
                    }
                    if (stateValue && Array.from(stateInput.options).some(opt => opt.value === stateValue)) {
                        stateInput.value = stateValue;
                    }
                }
            } catch (error) {
                console.warn('Reverse geocoding error:', error);
                if (statusEl) {
                    statusEl.innerHTML += '<br><span style="color: #dc3545;">Could not auto-fill address from location.</span>';
                }
            }
        }

        async function geocodeAddress(query) {
            if (!query) {
                return null;
            }
            const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&addressdetails=1&q=${encodeURIComponent(query)}`;
            const response = await fetch(url, {
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'TrueSightDAO-DApp/1.0 (+https://truesightdao.github.io/dapp/)'
                }
            });
            if (!response.ok) {
                throw new Error('Forward geocoding failed');
            }
            const results = await response.json();
            if (Array.isArray(results) && results.length > 0) {
                const result = results[0];
                const lat = parseFloat(result.lat);
                const lng = parseFloat(result.lon);
                if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
                    return { lat, lng, displayName: result.display_name || '' };
                }
            }
            return null;
        }

        async function ensureNewStoreCoordinates(showStatus = true) {
            const latInput = document.getElementById('newStoreLat');
            const lngInput = document.getElementById('newStoreLng');
            const statusEl = document.getElementById('newStoreLocationStatus');
            const addressInput = document.getElementById('newStoreAddress');
            const cityInput = document.getElementById('newStoreCity');
            const stateSelect = document.getElementById('newStoreState');

            if (latInput && lngInput && latInput.value && lngInput.value) {
                return true;
            }

            // Build geocoding query from address components
            const parts = [];
            if (addressInput && addressInput.value.trim()) {
                const addressValue = addressInput.value.trim();
                // If address already contains city/state (formatted address), use it as-is
                // Otherwise, build from components
                if (addressValue.includes(',') && (cityInput?.value || stateSelect?.value)) {
                    // Likely a formatted address, use it alone
                    parts.push(addressValue);
                } else {
                    // Just street address, add city and state
                    parts.push(addressValue);
                    if (cityInput && cityInput.value.trim()) {
                        parts.push(cityInput.value.trim());
                    }
                    if (stateSelect && stateSelect.value.trim()) {
                        parts.push(stateSelect.value.trim());
                    }
                }
            } else {
                // No address, try city and state
            if (cityInput && cityInput.value.trim()) {
                parts.push(cityInput.value.trim());
            }
            if (stateSelect && stateSelect.value.trim()) {
                parts.push(stateSelect.value.trim());
            }
            }
            
            // Only add USA if we have at least one component
            if (parts.length > 0) {
            parts.push('USA');
            }

            const query = parts.filter(Boolean).join(', ');
            if (!query || query.trim() === 'USA') {
                if (showStatus && statusEl) {
                    statusEl.innerHTML = '<span style="color: #dc3545;">Add an address, city, or state to capture coordinates.</span>';
                }
                return false;
            }

            if (showStatus && statusEl) {
                statusEl.innerHTML = '<span style="color: #007bff;">ðŸ” Looking up coordinates...</span>';
            }

            try {
                const result = await geocodeAddress(query);
                if (result) {
                    if (latInput) latInput.value = result.lat;
                    if (lngInput) lngInput.value = result.lng;
                    updateNewStoreCoordinatesUI();
                    if (showStatus && statusEl) {
                        statusEl.innerHTML = `<span style="color: #28a745;">ðŸ“ Coordinates found: ${result.lat.toFixed(4)}, ${result.lng.toFixed(4)}</span>`;
                    }
                    return true;
                }
                if (showStatus && statusEl) {
                    statusEl.innerHTML = '<span style="color: #dc3545;">Could not determine coordinates from the address. Please refine details or use "Use Current Location".</span>';
                }
            } catch (error) {
                console.warn('Geocoding error:', error);
                if (showStatus && statusEl) {
                    statusEl.innerHTML = '<span style="color: #dc3545;">Error capturing coordinates. Please try again or use "Use Current Location".</span>';
                }
            }
            return false;
        }

        function normalizeWebsiteUrl(url) {
            if (!url) return '';
            let value = url.trim();
            if (!value) return '';
            if (!/^https?:\/\//i.test(value)) {
                value = 'https://' + value.replace(/^\/+/, '');
            }
            return value;
        }

        function normalizeInstagramUrl(value) {
            if (!value) return '';
            let handle = value.trim();
            if (!handle) return '';
            if (/^https?:\/\//i.test(handle)) {
                return handle;
            }
            if (handle.startsWith('@')) {
                handle = handle.substring(1);
            }
            handle = handle.replace(/^\/+/, '');
            return `https://instagram.com/${handle}`;
        }

        async function handleNewStoreFormSubmit(event) {
            event.preventDefault();
            const form = event.target;
            const messageEl = document.getElementById('newStoreStatusMessage');
            const submitBtn = document.getElementById('newStoreSubmitBtn');
            const locationStatusEl = document.getElementById('newStoreLocationStatus');

            if (messageEl) messageEl.innerHTML = '';

            if (interactionMode !== 'interactive') {
                if (messageEl) {
                    messageEl.innerHTML = '<span style="color: #dc3545;">Connect your digital signature to submit new stores.</span>';
                }
                showSignatureNoticeOnce('Digital signature required to add stores.');
                return;
            }

            const shopName = document.getElementById('newStoreName').value.trim();
            const address = document.getElementById('newStoreAddress').value.trim();
            const city = document.getElementById('newStoreCity').value.trim();
            const state = document.getElementById('newStoreState').value.trim();
            const phone = document.getElementById('newStorePhone').value.trim();
            const email = document.getElementById('newStoreEmail').value.trim();
            const websiteRaw = document.getElementById('newStoreWebsite').value.trim();
            const instagramRaw = document.getElementById('newStoreInstagram').value.trim();
            const shopType = document.getElementById('newStoreShopType').value.trim();
            const status = document.getElementById('newStoreStatus').value.trim() || 'Shortlisted';
            const remarks = document.getElementById('newStoreRemarks').value.trim();
            let latitude = document.getElementById('newStoreLat').value.trim();
            let longitude = document.getElementById('newStoreLng').value.trim();

            const candidateKey = createStoreKey({
                name: shopName,
                address,
                city,
                state
            });

            if (candidateKey) {
                const existingEntry = knownStoresByKey.get(candidateKey.toLowerCase());
                if (existingEntry) {
                    const existingStore = existingEntry.store || {};
                    if (messageEl) {
                        const statusLabel = existingStore.status ? ` (Status: ${escapeHtml(existingStore.status)})` : '';
                        messageEl.innerHTML = `
                            <div class="duplicate-notice">
                                âš ï¸ Already on the hit list as <strong>${escapeHtml(existingStore.name || shopName)}</strong>${statusLabel}.
                                <button type="button" id="viewExistingStoreBtn">View existing entry</button>
                            </div>
                        `;
                        const viewBtn = document.getElementById('viewExistingStoreBtn');
                        if (viewBtn) {
                            viewBtn.addEventListener('click', function() {
                                focusStoreCard(existingEntry.index);
                                const card = document.getElementById('store-card-' + existingEntry.index);
                                if (card) {
                                    card.classList.add('duplicate-highlight');
                                    setTimeout(function() {
                                        card.classList.remove('duplicate-highlight');
                                    }, 2400);
                                }
                            });
                        }
                    }
                    // Change button to "Reset Form" when duplicate is detected
                    if (submitBtn) {
                        submitBtn.textContent = 'Reset Form';
                        submitBtn.type = 'button';
                        submitBtn.disabled = false;
                        // Store original button state
                        if (!submitBtn.dataset.originalType) {
                            submitBtn.dataset.originalType = 'submit';
                            submitBtn.dataset.originalText = 'Save New Store';
                        }
                        // Remove any existing click handlers by replacing the button
                        const newBtn = submitBtn.cloneNode(true);
                        submitBtn.parentNode.replaceChild(newBtn, submitBtn);
                        // Add reset form handler to the new button
                        newBtn.addEventListener('click', resetNewStoreForm);
                    }
                    return;
                }
            }

            if (!latitude || !longitude) {
                const coordsFound = await ensureNewStoreCoordinates(true);
                if (coordsFound) {
                    latitude = document.getElementById('newStoreLat').value.trim();
                    longitude = document.getElementById('newStoreLng').value.trim();
                }
            }

            if (!shopName) {
                if (messageEl) messageEl.innerHTML = '<span style="color: #dc3545;">Shop name is required.</span>';
                return;
            }

            if (!latitude || !longitude) {
                if (messageEl) messageEl.innerHTML = '<span style="color: #dc3545;">Unable to determine store coordinates. Please refine the address or use "Use Current Location".</span>';
                return;
            }

            const website = websiteRaw ? normalizeWebsiteUrl(websiteRaw) : '';
            const instagram = instagramRaw ? normalizeInstagramUrl(instagramRaw) : '';

            const params = new URLSearchParams();
            params.append('action', 'add_store');
            params.append('shop_name', shopName);
            params.append('status', status);
            params.append('shop_type', shopType || '');
            params.append('remarks', remarks || '');
            params.append('address', address || '');
            params.append('city', city || '');
            params.append('state', state || '');
            params.append('phone', phone || '');
            if (email) params.append('email', email);
            if (website) params.append('website', website);
            if (instagram) params.append('instagram', instagram);
            params.append('latitude', latitude);
            params.append('longitude', longitude);

            const publicKey = localStorage.getItem('publicKey');
            if (publicKey) {
                params.append('digital_signature', publicKey);
                params.append('submitted_by', publicKey);
            }

            if (messageEl) {
                messageEl.innerHTML = '<span style="color: #007bff;">Saving new store...</span>';
            }
            if (submitBtn) submitBtn.disabled = true;

            try {
                const response = await fetch(`${API_URL}?${params.toString()}`);
                const data = await response.json();
                if (data.success) {
                    if (messageEl) {
                        messageEl.innerHTML = `<span style="color: #28a745;">âœ… ${data.message || 'Store saved.'}</span>`;
                    }
                    form.reset();
                    if (locationStatusEl) {
                        locationStatusEl.innerHTML = '';
                    }
                    document.getElementById('newStoreLat').value = '';
                    document.getElementById('newStoreLng').value = '';
                    updateNewStoreCoordinatesUI();
                    setNewStoreCardExpanded(false);
                    
                    // Invalidate map size after form collapse to ensure proper rendering
                    setTimeout(() => {
                        if (map) {
                            map.invalidateSize();
                        }
                    }, 300);
                    
                    if (currentLat !== null && currentLng !== null) {
                        setTimeout(() => {
                            // Invalidate map size again before searching to ensure proper bounds calculation
                            if (map) {
                                map.invalidateSize();
                            }
                            searchStores();
                        }, 1000);
                    }
                } else {
                    const errorMsg = data.error || data.message || 'Unable to save store.';
                    if (messageEl) {
                        messageEl.innerHTML = `<span style="color: #dc3545;">âŒ ${errorMsg}</span>`;
                    }
                }
            } catch (error) {
                console.error('New store submission error:', error);
                if (messageEl) {
                    messageEl.innerHTML = `<span style="color: #dc3545;">âŒ Error saving store: ${error.message}</span>`;
                }
            } finally {
                if (submitBtn) submitBtn.disabled = false;
            }
        }

        function buildStoreDetails(store, index) {
            // Build Google Maps URL
            const mapsQueryParts = [
                store.name || '',
                store.address || '',
                store.city || '',
                store.state || ''
            ].join(' ').trim();
            const mapsQuery = mapsQueryParts ? encodeURIComponent(mapsQueryParts) : '';
            const mapsUrl = mapsQuery
                ? `https://www.google.com/maps/search/?api=1&query=${mapsQuery}`
                : `https://www.google.com/maps/search/?api=1&query=${store.latitude},${store.longitude}`;
            const fullAddress = `${escapeHtml(store.address || '')}${store.city ? ', ' + escapeHtml(store.city) : ''}${store.state ? ', ' + escapeHtml(store.state) : ''}`.trim();
            
            let html = `
                <div class="store-details-section">
                    <div class="store-details-title">ðŸ“ Location</div>
                    <div class="store-details-content">
                        <strong>Address:</strong> ${escapeHtml(store.address || 'N/A')}<br>
                        <strong>City:</strong> ${escapeHtml(store.city || 'N/A')}<br>
                        <strong>State:</strong> ${escapeHtml(store.state || 'N/A')}<br>
                        <strong>Distance:</strong> ${store.distance} miles away<br>
                        <strong>Coordinates:</strong> ${store.latitude.toFixed(6)}, ${store.longitude.toFixed(6)}<br>
                        <a href="${mapsUrl}" target="_blank" class="store-details-link" style="display: inline-block; margin-top: 0.5rem; font-weight: 600;">ðŸ—ºï¸ View on Google Maps</a>
                    </div>
                </div>
            `;

            if (store.shop_type) {
                html += `
                    <div class="store-details-section">
                        <div class="store-details-title">ðŸª Shop Type</div>
                        <div class="store-details-content">${escapeHtml(store.shop_type)}</div>
                    </div>
                `;
            }

            if (store.phone || store.email || store.website || store.instagram) {
                html += `
                    <div class="store-details-section">
                        <div class="store-details-title">ðŸ“ž Contact Information</div>
                        <div class="store-details-content">
                            ${store.phone ? '<strong>Phone:</strong> <a href="tel:' + escapeHtml(store.phone) + '" class="store-details-link">' + escapeHtml(store.phone) + '</a><br>' : ''}
                            ${store.email ? '<strong>Email:</strong> <a href="mailto:' + escapeHtml(store.email) + '" class="store-details-link">' + escapeHtml(store.email) + '</a><br>' : ''}
                            ${store.website ? '<strong>Website:</strong> <a href="' + escapeHtml(store.website) + '" target="_blank" class="store-details-link">' + escapeHtml(store.website) + '</a><br>' : ''}
                            ${store.instagram ? '<strong>Instagram:</strong> <a href="' + escapeHtml(store.instagram) + '" target="_blank" class="store-details-link">View Profile</a><br>' : ''}
                        </div>
                    </div>
                `;
            }

            if (store.contact_date || store.contact_method) {
                html += `
                    <div class="store-details-section">
                        <div class="store-details-title">ðŸ“… Contact History</div>
                        <div class="store-details-content">
                            ${store.contact_date ? '<strong>Contact Date:</strong> ' + escapeHtml(store.contact_date) + '<br>' : ''}
                            ${store.contact_method ? '<strong>Contact Method:</strong> ' + escapeHtml(store.contact_method) + '<br>' : ''}
                        </div>
                    </div>
                `;
            }

            const followUpLines = [];
            if (store.follow_up_date) {
                followUpLines.push('<strong>Follow-up Date:</strong> ' + escapeHtml(store.follow_up_date));
            }
            if (store.contact_person) {
                followUpLines.push('<strong>Contact Person:</strong> ' + escapeHtml(store.contact_person));
            }
            if (store.owner_name) {
                followUpLines.push('<strong>Owner:</strong> ' + escapeHtml(store.owner_name));
            }
            if (store.referral) {
                followUpLines.push('<strong>Referral:</strong> ' + escapeHtml(store.referral));
            }
            if (store.product_interest) {
                followUpLines.push('<strong>Product Interest:</strong> ' + escapeHtml(store.product_interest));
            }
            if (store.visit_date) {
                followUpLines.push('<strong>Visit Date:</strong> ' + escapeHtml(store.visit_date));
            }
            if (store.outcome) {
                followUpLines.push('<strong>Outcome:</strong> ' + escapeHtml(store.outcome));
            }
            if (store.follow_up_event_link) {
                const eventUrl = encodeURI(store.follow_up_event_link);
                followUpLines.push('<a href="' + eventUrl + '" target="_blank" class="store-details-link">ðŸ“… View Calendar Event</a>');
            }
            if (followUpLines.length > 0) {
                html += `
                    <div class="store-details-section">
                        <div class="store-details-title">ðŸ“ž Follow-up Plan</div>
                        <div class="store-details-content">${followUpLines.join('<br>')}</div>
                    </div>
                `;
            }

            if (store.notes || store.sales_process_notes) {
                const notesLines = [];
                if (store.notes) {
                    notesLines.push('<strong>Store Notes:</strong><br>' + escapeHtml(store.notes));
                }
                if (store.sales_process_notes) {
                    notesLines.push('<strong>Sales Process Notes:</strong><br>' + escapeHtml(store.sales_process_notes));
                }
                html += `
                    <div class="store-details-section">
                        <div class="store-details-title">ðŸ“ Notes</div>
                        <div class="store-details-content">${notesLines.join('<br><br>')}</div>
                    </div>
                `;
            }

            const shareMessageId = `shareMessage-${index}`;
            html += `
                <div class="store-details-section">
                    <div class="store-details-title">ðŸ“£ Share This Store</div>
                    <div class="store-details-content share-actions">
                        <button type="button"
                                class="btn"
                                onclick="handleStoreShare(event, ${index})">
                            Share Updates
                        </button>
                        <div id="${shareMessageId}" class="share-message" aria-live="polite"></div>
                    </div>
                </div>
            `;

            // Add status update section
            // Use index-based ID to avoid issues with special characters in shop names
            const statusSelectId = `statusUpdate-${index}`;
            const statusMessageId = `statusUpdateMessage-${index}`;
            const shopNameEscaped = escapeHtml(store.name).replace(/'/g, "\\'");
            
            html += `
                <div class="store-details-section">
                    <div class="store-details-title">âœï¸ Update Status & Shop Type</div>
                    <div class="store-details-content">
                        <label for="${statusSelectId}" style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Status:</label>
                        <select id="${statusSelectId}" 
                                data-shop-index="${index}"
                                class="status-update-select"
                                data-requires-signature="true"
                                style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; margin-bottom: 0.75rem;">
                            <option value="Research" ${store.status === 'Research' ? 'selected' : ''}>Research</option>
                            <option value="Shortlisted" ${store.status === 'Shortlisted' ? 'selected' : ''}>Shortlisted</option>
                            <option value="Instagram Followed" ${store.status === 'Instagram Followed' ? 'selected' : ''}>Instagram Followed</option>
                            <option value="Contacted" ${store.status === 'Contacted' ? 'selected' : ''}>Contacted</option>
                            <option value="Manager Follow-up" ${store.status === 'Manager Follow-up' ? 'selected' : ''}>Manager Follow-up</option>
                            <option value="Meeting Scheduled" ${store.status === 'Meeting Scheduled' ? 'selected' : ''}>Meeting Scheduled</option>
                            <option value="Followed Up" ${store.status === 'Followed Up' ? 'selected' : ''}>Followed Up</option>
                            <option value="Partnered" ${store.status === 'Partnered' ? 'selected' : ''}>Partnered</option>
                            <option value="On Hold" ${store.status === 'On Hold' ? 'selected' : ''}>On Hold</option>
                            <option value="Rejected" ${store.status === 'Rejected' ? 'selected' : ''}>Rejected</option>
                            <option value="Not Appropriate" ${store.status === 'Not Appropriate' ? 'selected' : ''}>Not Appropriate</option>
                        </select>
                        <label for="shopTypeUpdate-${index}" style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Shop Type:</label>
                        <select id="shopTypeUpdate-${index}" 
                                data-shop-index="${index}"
                                class="shop-type-update-select"
                                data-requires-signature="true"
                                style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem; margin-bottom: 0.75rem;">
                            <option value="">-- Select Shop Type --</option>
                            <option value="Metaphysical/Spiritual" ${store.shop_type === 'Metaphysical/Spiritual' ? 'selected' : ''}>Metaphysical / Spiritual</option>
                            <option value="Wellness Center" ${store.shop_type === 'Wellness Center' ? 'selected' : ''}>Wellness Center</option>
                            <option value="Health Food Store" ${store.shop_type === 'Health Food Store' ? 'selected' : ''}>Health Food Store</option>
                            <option value="Natural Goods" ${store.shop_type === 'Natural Goods' ? 'selected' : ''}>Natural Goods</option>
                            <option value="Conscious Cafe" ${store.shop_type === 'Conscious Cafe' ? 'selected' : ''}>Conscious Cafe</option>
                            <option value="Boutique Chocolate" ${store.shop_type === 'Boutique Chocolate' ? 'selected' : ''}>Boutique Chocolate</option>
                            <option value="Antique Store" ${store.shop_type === 'Antique Store' ? 'selected' : ''}>Antique Store</option>
                            <option value="Gift Shop" ${store.shop_type === 'Gift Shop' ? 'selected' : ''}>Gift Shop</option>
                            <option value="Candy Store" ${store.shop_type === 'Candy Store' ? 'selected' : ''}>Candy Store</option>
                            <option value="Yoga Studio" ${store.shop_type === 'Yoga Studio' ? 'selected' : ''}>Yoga Studio</option>
                            <option value="Other" ${store.shop_type === 'Other' ? 'selected' : ''}>Other</option>
                        </select>
                        <label for="statusRemarks-${index}" style="display: block; margin: 0.75rem 0 0.5rem; font-weight: 600;">Remarks (optional):</label>
                        <textarea id="statusRemarks-${index}"
                                  rows="3"
                                  placeholder="Add context, next steps, or notes captured in the field..."
                                  data-requires-signature="true"
                                  style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; font-size: 0.95rem; resize: vertical;"></textarea>
                        <button onclick="updateStoreStatusByIndex(${index})" 
                                class="btn" 
                                type="button"
                                data-status-update="true"
                                data-requires-signature="true"
                                style="width: 100%; padding: 0.6rem; font-size: 0.95rem; margin-top: 0.5rem;">
                            Update Status & Shop Type
                        </button>
                        <div id="${statusMessageId}" style="margin-top: 0.5rem; font-size: 0.9rem;"></div>
                    </div>
                </div>
            `;

            return html;
        }

        function toggleStoreDetails(index, event) {
            // Don't toggle if click was on an interactive element inside the card
            if (event) {
                const interactiveTags = ['BUTTON', 'SELECT', 'A', 'TEXTAREA', 'INPUT'];
                if (interactiveTags.includes(event.target.tagName)) {
                    return;
                }
                if (event.target.closest('button') || event.target.closest('select') ||
                    event.target.closest('a') || event.target.closest('textarea') ||
                    event.target.closest('input')) {
                    return;
                }
            }
            
            const card = document.querySelector(`[data-store-index="${index}"]`);
            if (!card) return;

            // Close other expanded cards (optional - remove if you want multiple open)
            document.querySelectorAll('.store-card.expanded').forEach(expandedCard => {
                if (expandedCard !== card) {
                    expandedCard.classList.remove('expanded');
                    const expandedDetails = expandedCard.querySelector('.store-details');
                    if (expandedDetails) {
                        expandedDetails.style.maxHeight = '';
                    }
                }
            });

            // Toggle this card
            const isExpanded = card.classList.toggle('expanded');
            const details = card.querySelector('.store-details');
            if (details) {
                if (isExpanded) {
                    details.style.maxHeight = details.scrollHeight + 'px';
                } else {
                    details.style.maxHeight = '';
                }
            }
        }

        function updateStoreStatusByIndex(index) {
            const store = window.storesData[index];
            if (!store) {
                console.error('Store not found at index:', index);
                return;
            }

            const shopName = store.name;
            const selectElement = document.getElementById(`statusUpdate-${index}`);
            const shopTypeElement = document.getElementById(`shopTypeUpdate-${index}`);
            const messageElement = document.getElementById(`statusUpdateMessage-${index}`);
            const remarksElement = document.getElementById(`statusRemarks-${index}`);
            
            if (interactionMode !== 'interactive') {
                if (messageElement) {
                    messageElement.innerHTML = '<span style="color: #dc3545;">Connect your digital signature to update statuses.</span>';
                }
                showSignatureNoticeOnce('Digital signature required to update store status.');
                return;
            }

            if (!selectElement || !messageElement) {
                console.error('Status update elements not found');
                return;
            }
            
            const newStatus = selectElement.value;
            const newShopType = shopTypeElement ? shopTypeElement.value.trim() : '';
            const currentStatus = store.status;
            const currentShopType = store.shop_type || '';
            const remarks = remarksElement ? remarksElement.value.trim() : '';

            // Don't update if nothing changed
            if (newStatus === currentStatus && newShopType === currentShopType && !remarks) {
                messageElement.innerHTML = '<span style="color: #6c757d;">Status and shop type unchanged and no remarks added</span>';                                         
                return;
            }

            // Show loading state
            messageElement.innerHTML = '<span style="color: #007bff;">Updating status and shop type...</span>';
            selectElement.disabled = true;
            if (shopTypeElement) {
                shopTypeElement.disabled = true;
            }
            if (remarksElement) {
                remarksElement.disabled = true;
            }

            // Get digital signature (public key) from localStorage
            const publicKey = localStorage.getItem('publicKey');
            
            // Build URL for status update
            const params = new URLSearchParams({
                action: 'update_status',
                shop_name: shopName,
                new_status: newStatus
            });
            if (newShopType) {
                params.append('shop_type', newShopType);
            }
            if (remarks) {
                params.append('remarks', remarks);
            }
            
            // Add digital signature if available
            if (publicKey) {
                params.append('digital_signature', publicKey);
                params.append('submitted_by', publicKey);
            }

            // Call API to update status
            fetch(`${API_URL}?${params.toString()}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        messageElement.innerHTML = `<span style="color: #28a745;">âœ… ${data.message}</span>`;
                        
                        // Update the store data
                        window.storesData[index].status = newStatus;
                        if (newShopType) {
                            window.storesData[index].shop_type = newShopType;
                        }
                        if (remarksElement) {
                            remarksElement.value = '';
                        }
                        
                        // Update the badge in the card
                        const card = document.querySelector(`[data-store-index="${index}"]`);
                        if (card) {
                            const badgeContainer = card.querySelector('.store-meta');
                            if (badgeContainer) {
                                // Find and update status badge
                                const statusBadge = getStatusBadge(newStatus);
                                // Replace the status badge (it's the second badge)
                                const badges = badgeContainer.querySelectorAll('.store-badge');
                                if (badges.length > 1) {
                                    badges[1].outerHTML = statusBadge;
                                }
                                
                                // Update shop type display if changed
                                if (newShopType) {
                                    const shopTypeSpans = badgeContainer.querySelectorAll('span');
                                    let shopTypeSpan = null;
                                    shopTypeSpans.forEach(span => {
                                        if (span.textContent && span.textContent.startsWith('Type:')) {
                                            shopTypeSpan = span;
                                        }
                                    });
                                    
                                    if (shopTypeSpan) {
                                        shopTypeSpan.textContent = 'Type: ' + newShopType;
                                    } else {
                                        // Create new shop type span if it doesn't exist
                                        const newSpan = document.createElement('span');
                                        newSpan.textContent = 'Type: ' + newShopType;
                                        badgeContainer.appendChild(newSpan);
                                    }
                                }
                            }
                        }
                        
                        // Refresh the stores list after a short delay to show updated status
                        setTimeout(() => {
                            if (currentLat && currentLng) {
                                // Re-search to get updated data from the sheet
                                searchStores();
                            }
                        }, 1500);
                        selectElement.disabled = false;
                        if (remarksElement) {
                            remarksElement.disabled = false;
                        }
                    } else {
                        messageElement.innerHTML = `<span style="color: #dc3545;">âŒ Error: ${data.error || data.message || 'Unknown error'}</span>`;
                        selectElement.disabled = false;
                        if (remarksElement) {
                            remarksElement.disabled = false;
                        }
                    }
                })
                .catch(error => {
                    messageElement.innerHTML = `<span style="color: #dc3545;">âŒ Error updating status: ${error.message}</span>`;
                    selectElement.disabled = false;
                    if (remarksElement) {
                        remarksElement.disabled = false;
                    }
                    console.error('Error:', error);
                });
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
    <!-- Reload latest version link -->
    <script>
        (function() {
            const div = document.createElement('div');
            div.style.textAlign = 'center';
            div.style.marginTop = '1rem';
            const url = new URL(window.location.href);
            url.searchParams.set('reload', 'true');
            const a = document.createElement('a');
            a.href = url.toString();
            a.textContent = 'Reload Latest Version';
            a.style.fontSize = '0.8rem';
            a.style.color = '#007bff';
            a.style.textDecoration = 'none';
            div.appendChild(a);
            document.body.appendChild(div);
        })();
    </script>
    <!-- View Source Code link -->
    <script>
        (function() {
            const div = document.createElement('div');
            div.style.textAlign = 'center';
            div.style.marginTop = '1rem';
            const a = document.createElement('a');
            a.href = 'https://github.com/TrueSightDAO/dapp/blob/main/stores_nearby.html';
            a.textContent = 'View Source Code';
            a.style.fontSize = '0.8rem';
            a.style.color = '#007bff';
            a.style.textDecoration = 'none';
            div.appendChild(a);
            document.body.appendChild(div);
        })();
    </script>
</body>
</html>

